/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import {Rule, SchematicContext, Tree} from '@angular-devkit/schematics';
import {Schema} from './schema';
import {
  argbFromHex,
  hexFromArgb,
  TonalPalette,
  Hct,
  DynamicScheme,
  DislikeAnalyzer,
  TemperatureCache,
} from '@material/material-color-utilities';

// For each color tonal palettes are created using the following hue tones. The
// tonal palettes then get used to create the different color roles (ex.
// on-primary) https://m3.material.io/styles/color/system/how-the-system-works
const HUE_TONES = [0, 10, 20, 25, 30, 35, 40, 50, 60, 70, 80, 90, 95, 98, 99, 100];
// Map of neutral hues to the previous/next hues that
// can be used to estimate them, in case they're missing.
const NEUTRAL_HUES = new Map<number, {prev: number; next: number}>([
  [4, {prev: 0, next: 10}],
  [6, {prev: 0, next: 10}],
  [12, {prev: 10, next: 20}],
  [17, {prev: 10, next: 20}],
  [22, {prev: 20, next: 25}],
  [24, {prev: 20, next: 25}],
  [87, {prev: 80, next: 90}],
  [92, {prev: 90, next: 95}],
  [94, {prev: 90, next: 95}],
  [96, {prev: 95, next: 98}],
]);

// Note: Some of the color tokens refer to additional hue tones, but this only
// applies for the neutral color palette (ex. surface container is neutral
// palette's 94 tone). https://m3.material.io/styles/color/static/baseline
const NEUTRAL_HUE_TONES = [...HUE_TONES, ...NEUTRAL_HUES.keys()];

/**
 * Gets color tonal palettes generated by Material from the provided color.
 * @param primaryPalette Tonal palette that represents primary.
 * @param secondaryPalette Tonal palette that represents secondary.
 * @param tertiaryPalette Tonal palette that represents tertiary.
 * @param neutralPalette Tonal palette that represents neutral.
 * @param neutralVariantPalette Tonal palette that represents neutral variant.
 * @param isDark Boolean to represent if the scheme is for a dark or light theme.
 * @param contrastLevel Number between -1 and 1 for the contrast level. 0 is the standard contrast
 * and 1 represents high contrast.
 * @returns Dynamic scheme for provided theme and contrast level
 */
function getMaterialDynamicScheme(
  primaryPalette: TonalPalette,
  secondaryPalette: TonalPalette,
  tertiaryPalette: TonalPalette,
  neutralPalette: TonalPalette,
  neutralVariantPalette: TonalPalette,
  isDark: boolean,
  contrastLevel: number,
): DynamicScheme {
  return new DynamicScheme({
    sourceColorArgb: primaryPalette.keyColor.toInt(),
    variant: 6, // Variant.FIDELITY, used number representation since enum is not accessible outside of @material/material-color-utilities
    contrastLevel: contrastLevel,
    isDark: isDark,
    primaryPalette: primaryPalette,
    secondaryPalette: secondaryPalette,
    tertiaryPalette: tertiaryPalette,
    neutralPalette: neutralPalette,
    neutralVariantPalette: neutralVariantPalette,
  });
}

/**
 * Gets the scss representation of the provided color palettes.
 * @param colorPalettes Map of colors and their hue tones and values.
 * @returns String of the color palettes scss.
 */
function getColorPalettesSCSS(colorPalettes: Map<string, Map<number, string>>): string {
  let scss = '(\n';
  for (const [variant, palette] of colorPalettes!.entries()) {
    scss += '  ' + variant + ': (\n';
    for (const [key, value] of palette.entries()) {
      scss += '    ' + key + ': ' + value + ',\n';
    }
    scss += '  ),\n';
  }
  scss += ');';
  return scss;
}

/**
 * Gets map of all the color tonal palettes with their tones and colors from provided palettes.
 * @param primaryPalette Tonal palette that represents primary.
 * @param secondaryPalette Tonal palette that represents secondary.
 * @param tertiaryPalette Tonal palette that represents tertiary.
 * @param neutralPalette Tonal palette that represents neutral.
 * @param neutralVariantPalette Tonal palette that represents neutral variant.
 * @param errorPalette Tonal palette that represents error.
 * @returns Map with the colors and their hue tones and values.
 */
function getMapFromColorTonalPalettes(
  primaryPalette: TonalPalette,
  secondaryPalette: TonalPalette,
  tertiaryPalette: TonalPalette,
  neutralPalette: TonalPalette,
  neutralVariantPalette: TonalPalette,
  errorPalette: TonalPalette,
) {
  const tonalPalettes = {
    primary: primaryPalette,
    secondary: secondaryPalette,
    tertiary: tertiaryPalette,
    neutral: neutralPalette,
    neutralVariant: neutralVariantPalette,
    error: errorPalette,
  };
  const palettes: Map<string, Map<number, string>> = new Map();
  for (const [key, palette] of Object.entries(tonalPalettes)) {
    const paletteKey = key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    const tones = paletteKey === 'neutral' ? NEUTRAL_HUE_TONES : HUE_TONES;
    const colorPalette: Map<number, string> = new Map();
    for (const tone of tones) {
      const color = hexFromArgb(palette.tone(tone));
      colorPalette.set(tone, color);
    }
    palettes.set(paletteKey, colorPalette);
  }
  return palettes;
}

/**
 * Gets the generated scss from the provided color palettes and theme types.
 * @param colorPalettes Map of colors and their hue tones and values.
 * @param colorComment Comment with original hex colors used to generate palettes.
 * @returns String of the generated theme scss.
 */
export function generateSCSSTheme(
  colorPalettes: Map<string, Map<number, string>>,
  colorComment: string,
): string {
  let scss = [
    "// This file was generated by running 'ng generate @angular/material:theme-color'.",
    '// Proceed with caution if making changes to this file.',
    '',
    "@use 'sass:map';",
    "@use '@angular/material' as mat;",
    '',
    '// Note: ' + colorComment,
    '$_palettes: ' + getColorPalettesSCSS(colorPalettes),
    '',
    '$_rest: (',
    '  secondary: map.get($_palettes, secondary),',
    '  neutral: map.get($_palettes, neutral),',
    '  neutral-variant: map.get($_palettes,  neutral-variant),',
    '  error: map.get($_palettes, error),',
    ');',
    '',
    '$primary-palette: map.merge(map.get($_palettes, primary), $_rest);',
    '$tertiary-palette: map.merge(map.get($_palettes, tertiary), $_rest);',
  ];

  return scss.join('\n');
}

/**
 * Gets map of system variables and their high contrast values.
 * @param primaryPalette Tonal palette that represents primary.
 * @param secondaryPalette Tonal palette that represents secondary.
 * @param tertiaryPalette Tonal palette that represents tertiary.
 * @param neutralPalette Tonal palette that represents neutral.
 * @param neutralVariantPalette Tonal palette that represents neutral variant.
 * @param isDark Boolean to represent if the scheme is for a dark or light theme.
 * @returns Map of system variables names and their high contrast values.
 */
function getHighContrastOverides(
  primaryPalette: TonalPalette,
  secondaryPalette: TonalPalette,
  tertiaryPalette: TonalPalette,
  neutralPalette: TonalPalette,
  neutralVariantPalette: TonalPalette,
  isDark: boolean,
): Map<string, string> {
  const scheme = getMaterialDynamicScheme(
    primaryPalette,
    secondaryPalette,
    tertiaryPalette,
    neutralPalette,
    neutralVariantPalette,
    isDark,
    1.0, // 1.0 is the maximum contrast level
  );

  const overrides = new Map<string, string>();

  // Set system variables with values from primary palette
  overrides.set('primary', hexFromArgb(scheme.primary));
  overrides.set('on-primary', hexFromArgb(scheme.onPrimary));
  overrides.set('primary-container', hexFromArgb(scheme.primaryContainer));
  overrides.set('on-primary-container', hexFromArgb(scheme.onPrimaryContainer));
  overrides.set('inverse-primary', hexFromArgb(scheme.inversePrimary));
  overrides.set('primary-fixed', hexFromArgb(scheme.primaryFixed));
  overrides.set('primary-fixed-dim', hexFromArgb(scheme.primaryFixedDim));
  overrides.set('on-primary-fixed', hexFromArgb(scheme.onPrimaryFixed));
  overrides.set('on-primary-fixed-variant', hexFromArgb(scheme.onPrimaryFixedVariant));

  // Set system variables with values from secondary palette
  overrides.set('secondary', hexFromArgb(scheme.secondary));
  overrides.set('on-secondary', hexFromArgb(scheme.onSecondary));
  overrides.set('secondary-container', hexFromArgb(scheme.secondaryContainer));
  overrides.set('on-secondary-container', hexFromArgb(scheme.onSecondaryContainer));
  overrides.set('secondary-fixed', hexFromArgb(scheme.secondaryFixed));
  overrides.set('secondary-fixed-dim', hexFromArgb(scheme.secondaryFixedDim));
  overrides.set('on-secondary-fixed', hexFromArgb(scheme.onSecondaryFixed));
  overrides.set('on-secondary-fixed-variant', hexFromArgb(scheme.onSecondaryFixedVariant));

  // Set system variables with values from tertiary palette
  overrides.set('tertiary', hexFromArgb(scheme.tertiary));
  overrides.set('on-tertiary', hexFromArgb(scheme.onTertiary));
  overrides.set('tertiary-container', hexFromArgb(scheme.tertiaryContainer));
  overrides.set('on-tertiary-container', hexFromArgb(scheme.onTertiaryContainer));
  overrides.set('tertiary-fixed', hexFromArgb(scheme.tertiaryFixed));
  overrides.set('tertiary-fixed-dim', hexFromArgb(scheme.tertiaryFixedDim));
  overrides.set('on-tertiary-fixed', hexFromArgb(scheme.onTertiaryFixed));
  overrides.set('on-tertiary-fixed-variant', hexFromArgb(scheme.onTertiaryFixedVariant));

  // Set system variables with values from neutral palette
  overrides.set('background', hexFromArgb(scheme.background));
  overrides.set('on-background', hexFromArgb(scheme.onBackground));
  overrides.set('surface', hexFromArgb(scheme.surface));
  overrides.set('surface-dim', hexFromArgb(scheme.surfaceDim));
  overrides.set('surface-bright', hexFromArgb(scheme.surfaceBright));
  overrides.set('surface-container-lowest', hexFromArgb(scheme.surfaceContainerLowest));
  overrides.set('surface-container-lowest', hexFromArgb(scheme.surfaceContainerLow));
  overrides.set('surface-container', hexFromArgb(scheme.surfaceContainer));
  overrides.set('surface-container-high', hexFromArgb(scheme.surfaceContainerHigh));
  overrides.set('surface-container-highest', hexFromArgb(scheme.surfaceContainerHighest));
  overrides.set('on-surface', hexFromArgb(scheme.onSurface));
  overrides.set('shadow', hexFromArgb(scheme.shadow));
  overrides.set('scrim', hexFromArgb(scheme.scrim));
  overrides.set('surface-tint', hexFromArgb(scheme.surfaceTint));
  overrides.set('inverse-surface', hexFromArgb(scheme.inverseSurface));
  overrides.set('inverse-on-surface', hexFromArgb(scheme.inverseOnSurface));
  overrides.set('outline', hexFromArgb(scheme.outline));
  overrides.set('outline-variant', hexFromArgb(scheme.outlineVariant));

  // Set system variables with values from error palette
  overrides.set('error', hexFromArgb(scheme.error));
  overrides.set('on-error', hexFromArgb(scheme.onError));
  overrides.set('error-container', hexFromArgb(scheme.errorContainer));
  overrides.set('on-error-container', hexFromArgb(scheme.onErrorContainer));

  // Set system variables with values from neutral variant palette
  overrides.set('surface-variant', hexFromArgb(scheme.surfaceVariant));
  overrides.set('on-surface-variant', hexFromArgb(scheme.onSurfaceVariant));

  return overrides;
}

/**
 * Gets the scss representation of the high contrast override mixins.
 * @param primaryPalette Tonal palette that represents primary.
 * @param secondaryPalette Tonal palette that represents secondary.
 * @param tertiaryPalette Tonal palette that represents tertiary.
 * @param neutralPalette Tonal palette that represents neutral.
 * @param neutralVariantPalette Tonal palette that represents neutral variant.
 * @returns String of the generated high contrast mixins scss.
 */
function generateHighContrastOverrideMixinsSCSS(
  primaryPalette: TonalPalette,
  secondaryPalette: TonalPalette,
  tertiaryPalette: TonalPalette,
  neutralPalette: TonalPalette,
  neutralVariantPalette: TonalPalette,
): string {
  let scss = '\n';
  for (const themeType of ['light', 'dark']) {
    const overrides = getHighContrastOverides(
      primaryPalette,
      secondaryPalette,
      tertiaryPalette,
      neutralPalette,
      neutralVariantPalette,
      themeType === 'dark',
    );
    scss += '\n@mixin high-contrast-' + themeType + '-theme-overrides {\n';
    for (const [key, value] of overrides!.entries()) {
      scss += '  --mat-app-' + key + ': ' + value + ';\n';
    }
    scss += '};\n';
  }
  return scss;
}

/**
 * Gets Hct representation of Hex color.
 * @param color Hex color.
 * @returns Hct color.
 */
function getHctFromHex(color: string): Hct {
  try {
    return Hct.fromInt(argbFromHex(color));
  } catch (e) {
    throw new Error(
      'Cannot parse the specified color ' +
        color +
        '. Please verify it is a hex color (ex. #ffffff or ffffff).',
    );
  }
}

/**
 * Creates theme file for provided scss.
 * @param scss scss for the theme file.
 * @param tree Directory tree.
 * @param directory Directory path to place generated theme file.
 */
function createThemeFile(scss: string, tree: Tree, directory?: string) {
  const filePath = directory ? directory + '_theme-colors.scss' : '_theme-colors.scss';
  tree.create(filePath, scss);
}

export default function (options: Schema): Rule {
  return async (tree: Tree, context: SchematicContext) => {
    let colorComment = 'Color palettes are generated from primary: ' + options.primaryColor;

    // Create tonal palettes for each color and custom color overrides if applicable. Used for both
    // standard contrast and high contrast schemes since they share the same tonal palettes.
    // The math to generate the palettes follows how palettes are generated for SchemeFidelity
    // (https://github.com/material-foundation/material-color-utilities/blob/main/typescript/scheme/scheme_fidelity.ts).
    // Cannot create object directly since we allow users to enter custom colors for palettes and
    // palettes are readonly for a DynamicScheme.
    const primaryColorHct = getHctFromHex(options.primaryColor);
    const primaryPalette = TonalPalette.fromHct(primaryColorHct);

    let secondaryPalette;
    if (options.secondaryColor) {
      colorComment += ', secondary: ' + options.secondaryColor;
      secondaryPalette = TonalPalette.fromHct(getHctFromHex(options.secondaryColor));
    } else {
      secondaryPalette = TonalPalette.fromHueAndChroma(
        primaryColorHct.hue,
        Math.max(primaryColorHct.chroma - 32.0, primaryColorHct.chroma * 0.5),
      );
    }

    let tertiaryPalette;
    if (options.tertiaryColor) {
      colorComment += ', tertiary: ' + options.tertiaryColor;
      tertiaryPalette = TonalPalette.fromHct(getHctFromHex(options.tertiaryColor));
    } else {
      tertiaryPalette = TonalPalette.fromInt(
        DislikeAnalyzer.fixIfDisliked(
          new TemperatureCache(primaryColorHct).analogous(3, 6)[2],
        ).toInt(),
      );
    }

    let neutralPalette;
    if (options.neutralColor) {
      colorComment += ', neutral: ' + options.neutralColor;
      neutralPalette = TonalPalette.fromHct(getHctFromHex(options.neutralColor));
    } else {
      neutralPalette = TonalPalette.fromHueAndChroma(
        primaryColorHct.hue,
        primaryColorHct.chroma / 8.0,
      );
    }

    const neutralVariantPalette = TonalPalette.fromHueAndChroma(
      primaryColorHct.hue,
      primaryColorHct.chroma / 8.0 + 4.0,
    );

    // Create material dynamic scheme to generate the error tonal palette
    const errorPalette = getMaterialDynamicScheme(
      primaryPalette,
      secondaryPalette,
      tertiaryPalette,
      neutralPalette,
      neutralVariantPalette,
      false,
      0,
    ).errorPalette;

    // Create the generated SCSS file with the exportable palette users can use in their `theme`
    // mixin call.
    const colorPalettes = getMapFromColorTonalPalettes(
      primaryPalette,
      secondaryPalette,
      tertiaryPalette,
      neutralPalette,
      neutralVariantPalette,
      errorPalette,
    );
    let themeScss = generateSCSSTheme(colorPalettes, colorComment);

    // Add high contrast overrides mixins to generated file if specified
    if (options.includeHighContrast) {
      themeScss += generateHighContrastOverrideMixinsSCSS(
        primaryPalette,
        secondaryPalette,
        tertiaryPalette,
        neutralPalette,
        neutralVariantPalette,
      );
    }

    createThemeFile(themeScss, tree, options.directory);
  };
}
