## API Report File for "@angular/cdk_menu"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentInit } from '@angular/core';
import { ComponentRef } from '@angular/core';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { EmbeddedViewRef } from '@angular/core';
import { EnvironmentInjector } from '@angular/core';
import { EventEmitter } from '@angular/core';
import * as i0 from '@angular/core';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { Location as Location_2 } from '@angular/common';
import { NgIterable } from '@angular/core';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Optional } from '@angular/core';
import { QueryList } from '@angular/core';
import { Renderer2 } from '@angular/core';
import * as rxjs from 'rxjs';
import { Signal } from '@angular/core';
import { SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { Subscription } from 'rxjs';
import { TemplateRef } from '@angular/core';
import { TrackByFunction } from '@angular/core';
import { Type } from '@angular/core';
import { ViewContainerRef } from '@angular/core';

// @public
export const CDK_MENU: InjectionToken<Menu>;

// @public
export class CdkContextMenuTrigger extends CdkMenuTriggerBase implements OnDestroy {
    constructor();
    close(): void;
    disabled: boolean;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    open(coordinates: ContextMenuCoordinates): void;
    _openOnContextMenu(event: MouseEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkContextMenuTrigger, "[cdkContextMenuTriggerFor]", ["cdkContextMenuTriggerFor"], { "menuTemplateRef": { "alias": "cdkContextMenuTriggerFor"; "required": false; }; "menuPosition": { "alias": "cdkContextMenuPosition"; "required": false; }; "menuData": { "alias": "cdkContextMenuTriggerData"; "required": false; }; "disabled": { "alias": "cdkContextMenuDisabled"; "required": false; }; }, { "opened": "cdkContextMenuOpened"; "closed": "cdkContextMenuClosed"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkContextMenuTrigger, never>;
}

// @public
export class CdkMenu extends CdkMenuBase implements AfterContentInit, OnDestroy {
    constructor();
    readonly closed: EventEmitter<void>;
    _handleKeyEvent(event: KeyboardEvent): void;
    readonly isInline: boolean;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    readonly orientation = "vertical";
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenu, "[cdkMenu]", ["cdkMenu"], {}, { "closed": "closed"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenu, never>;
}

// @public
export class CdkMenuBar extends CdkMenuBase implements AfterContentInit {
    _handleKeyEvent(event: KeyboardEvent): void;
    readonly isInline = true;
    // (undocumented)
    ngAfterContentInit(): void;
    readonly orientation = "horizontal";
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuBar, "[cdkMenuBar]", ["cdkMenuBar"], {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuBar, never>;
}

// @public
export abstract class CdkMenuBase extends CdkMenuGroup implements Menu, AfterContentInit, OnDestroy {
    protected _allItems: QueryList<CdkMenuItem>;
    protected closeOpenMenu(menu: MenuStackItem, options?: {
        focusParentTrigger?: boolean;
    }): void;
    protected readonly destroyed: Subject<void>;
    protected readonly dir: Directionality | null;
    focusFirstItem(focusOrigin?: FocusOrigin): void;
    focusLastItem(focusOrigin?: FocusOrigin): void;
    _getTabIndex(): 0 | -1 | null;
    id: string;
    isInline: boolean;
    readonly items: QueryList<CdkMenuItem>;
    protected keyManager: FocusKeyManager<CdkMenuItem>;
    protected readonly menuAim: MenuAim | null;
    readonly menuStack: MenuStack;
    readonly nativeElement: HTMLElement;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    protected ngZone: NgZone;
    orientation: 'horizontal' | 'vertical';
    protected pointerTracker?: PointerFocusTracker<CdkMenuItem>;
    setActiveMenuItem(item: number | CdkMenuItem): void;
    protected triggerItem?: CdkMenuItem;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuBase, never, never, { "id": { "alias": "id"; "required": false; }; }, {}, ["_allItems"], never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuBase, never>;
}

// @public
export class CdkMenuGroup {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuGroup, "[cdkMenuGroup]", ["cdkMenuGroup"], {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuGroup, never>;
}

// @public
export class CdkMenuItem implements FocusableOption, FocusableElement, Toggler, OnDestroy {
    constructor();
    protected closeOnSpacebarTrigger: boolean;
    protected readonly destroyed: Subject<void>;
    // (undocumented)
    protected readonly _dir: Directionality | null;
    disabled: boolean;
    // (undocumented)
    readonly _elementRef: ElementRef<HTMLElement>;
    focus(): void;
    getLabel(): string;
    getMenu(): Menu | undefined;
    getMenuTrigger(): CdkMenuTrigger | null;
    get hasMenu(): boolean;
    isMenuOpen(): boolean;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    protected _ngZone: NgZone;
    _onKeydown(event: KeyboardEvent): void;
    readonly _parentMenu: Menu | null;
    _resetTabIndex(): void;
    _setTabIndex(event?: MouseEvent): void;
    _tabindex: 0 | -1;
    trigger(options?: {
        keepOpen: boolean;
    }): void;
    readonly triggered: EventEmitter<void>;
    typeaheadLabel: string | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItem, "[cdkMenuItem]", ["cdkMenuItem"], { "disabled": { "alias": "cdkMenuItemDisabled"; "required": false; }; "typeaheadLabel": { "alias": "cdkMenuitemTypeaheadLabel"; "required": false; }; }, { "triggered": "cdkMenuItemTriggered"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItem, never>;
}

// @public
export class CdkMenuItemCheckbox extends CdkMenuItemSelectable {
    trigger(options?: {
        keepOpen: boolean;
    }): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemCheckbox, "[cdkMenuItemCheckbox]", ["cdkMenuItemCheckbox"], {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemCheckbox, never>;
}

// @public
export class CdkMenuItemRadio extends CdkMenuItemSelectable implements OnDestroy {
    constructor();
    // (undocumented)
    ngOnDestroy(): void;
    trigger(options?: {
        keepOpen: boolean;
    }): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemRadio, "[cdkMenuItemRadio]", ["cdkMenuItemRadio"], {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemRadio, never>;
}

// @public
export abstract class CdkMenuItemSelectable extends CdkMenuItem {
    checked: boolean;
    protected closeOnSpacebarTrigger: boolean;
    // (undocumented)
    static ngAcceptInputType_checked: unknown;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuItemSelectable, never, never, { "checked": { "alias": "cdkMenuItemChecked"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuItemSelectable, never>;
}

// @public
export class CdkMenuModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<CdkMenuModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkMenuModule, never, [typeof OverlayModule, typeof CdkMenuBar, typeof CdkMenu, typeof CdkMenuItem, typeof CdkMenuItemRadio, typeof CdkMenuItemCheckbox, typeof CdkMenuTrigger, typeof CdkMenuGroup, typeof CdkContextMenuTrigger, typeof CdkTargetMenuAim], [typeof CdkMenuBar, typeof CdkMenu, typeof CdkMenuItem, typeof CdkMenuItemRadio, typeof CdkMenuItemCheckbox, typeof CdkMenuTrigger, typeof CdkMenuGroup, typeof CdkContextMenuTrigger, typeof CdkTargetMenuAim]>;
}

// @public
export class CdkMenuTrigger extends CdkMenuTriggerBase implements OnChanges, OnDestroy {
    constructor();
    close(): void;
    getMenu(): Menu | undefined;
    _handleClick(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    open(): void;
    _setHasFocus(hasFocus: boolean): void;
    toggle(): void;
    _toggleOnKeydown(event: KeyboardEvent): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuTrigger, "[cdkMenuTriggerFor]", ["cdkMenuTriggerFor"], { "menuTemplateRef": { "alias": "cdkMenuTriggerFor"; "required": false; }; "menuPosition": { "alias": "cdkMenuPosition"; "required": false; }; "menuData": { "alias": "cdkMenuTriggerData"; "required": false; }; }, { "opened": "cdkMenuOpened"; "closed": "cdkMenuClosed"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuTrigger, never>;
}

// @public
export abstract class CdkMenuTriggerBase implements OnDestroy {
    protected childMenu?: Menu;
    abstract close(): void;
    readonly closed: EventEmitter<void>;
    protected readonly destroyed: Subject<void>;
    protected getMenuContentPortal(): TemplatePortal<any>;
    readonly injector: Injector;
    protected isElementInsideMenuStack(element: Element): boolean;
    isOpen(): boolean;
    menuData: unknown;
    menuPosition: ConnectedPosition[];
    protected readonly menuScrollStrategy: () => ScrollStrategy;
    protected readonly menuStack: MenuStack;
    menuTemplateRef: TemplateRef<unknown> | null;
    // (undocumented)
    ngOnDestroy(): void;
    readonly opened: EventEmitter<void>;
    protected overlayRef: OverlayRef | null;
    registerChildMenu(child: Menu): void;
    protected readonly stopOutsideClicksListener: rxjs.Observable<void>;
    protected readonly viewContainerRef: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMenuTriggerBase, never, never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMenuTriggerBase, never>;
}

// @public
export class CdkTargetMenuAim {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTargetMenuAim, "[cdkTargetMenuAim]", ["cdkTargetMenuAim"], {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTargetMenuAim, never>;
}

// @public
export interface CloseOptions {
    focusNextOnEmpty?: FocusNext;
    focusParentTrigger?: boolean;
}

// @public
export type ContextMenuCoordinates = {
    x: number;
    y: number;
};

// @public
export interface FocusableElement {
    _elementRef: ElementRef<HTMLElement>;
}

// @public
export enum FocusNext {
    // (undocumented)
    currentItem = 2,
    // (undocumented)
    nextItem = 0,
    // (undocumented)
    previousItem = 1
}

// @public
export interface Menu extends MenuStackItem {
    focusFirstItem(focusOrigin: FocusOrigin): void;
    focusLastItem(focusOrigin: FocusOrigin): void;
    id: string;
    nativeElement: HTMLElement;
    readonly orientation: 'horizontal' | 'vertical';
}

// @public
export const MENU_AIM: InjectionToken<MenuAim>;

// @public
export const MENU_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;

// @public
export const MENU_STACK: InjectionToken<MenuStack>;

// @public
export const MENU_TRIGGER: InjectionToken<CdkMenuTriggerBase>;

// @public
export interface MenuAim {
    initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>): void;
    toggle(doToggle: () => void): void;
}

// @public
export class MenuStack {
    close(lastItem: MenuStackItem, options?: CloseOptions): void;
    closeAll(options?: CloseOptions): void;
    readonly closed: Observable<MenuStackCloseEvent>;
    closeSubMenuOf(lastItem: MenuStackItem): boolean;
    readonly emptied: Observable<FocusNext | undefined>;
    readonly hasFocus: Observable<boolean>;
    hasInlineMenu(): boolean;
    readonly id: string;
    static inline(orientation: 'vertical' | 'horizontal'): MenuStack;
    inlineMenuOrientation(): "vertical" | "horizontal" | null;
    isEmpty(): boolean;
    length(): number;
    peek(): MenuStackItem | undefined;
    push(menu: MenuStackItem): void;
    setHasFocus(hasFocus: boolean): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MenuStack, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MenuStack>;
}

// @public
export interface MenuStackCloseEvent {
    focusParentTrigger?: boolean;
    item: MenuStackItem;
}

// @public
export interface MenuStackItem {
    menuStack?: MenuStack;
}

// @public
class MenuTracker {
    update(trigger: CdkMenuTriggerBase): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MenuTracker, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MenuTracker>;
}
export { MenuTracker as ContextMenuTracker }
export { MenuTracker }

// @public
export const PARENT_OR_NEW_INLINE_MENU_STACK_PROVIDER: (orientation: "vertical" | "horizontal") => {
    provide: InjectionToken<MenuStack>;
    deps: Optional[][];
    useFactory: (parentMenuStack?: MenuStack) => MenuStack;
};

// @public
export const PARENT_OR_NEW_MENU_STACK_PROVIDER: {
    provide: InjectionToken<MenuStack>;
    deps: Optional[][];
    useFactory: (parentMenuStack?: MenuStack) => MenuStack;
};

// @public
export class PointerFocusTracker<T extends FocusableElement> {
    constructor(_renderer: Renderer2, _items: QueryList<T>);
    activeElement?: T;
    destroy(): void;
    readonly entered: Observable<T>;
    readonly exited: Observable<T>;
    previousElement?: T;
}

// @public
export class TargetMenuAim implements MenuAim, OnDestroy {
    initialize(menu: Menu, pointerTracker: PointerFocusTracker<FocusableElement & Toggler>): void;
    // (undocumented)
    ngOnDestroy(): void;
    toggle(doToggle: () => void): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<TargetMenuAim, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<TargetMenuAim>;
}

// @public
export interface Toggler {
    getMenu(): Menu | undefined;
}

// (No @packageDocumentation comment for this package)

```
