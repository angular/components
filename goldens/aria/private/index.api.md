## API Report File for "@angular/aria_private"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as _angular_core from '@angular/core';
import { OnDestroy } from '@angular/core';
import { untracked } from '@angular/core/primitives/signals';

// @public
export interface AccordionGroupInputs extends Omit<ListNavigationInputs<AccordionTriggerPattern> & ListFocusInputs<AccordionTriggerPattern> & Omit<ListExpansionInputs, 'items'>, 'focusMode'> {
    getItem: (e: Element | null | undefined) => AccordionTriggerPattern | undefined;
}

// @public
export class AccordionGroupPattern {
    constructor(inputs: AccordionGroupInputs);
    readonly expansionBehavior: ListExpansion;
    readonly focusBehavior: ListFocus<AccordionTriggerPattern>;
    // (undocumented)
    readonly inputs: AccordionGroupInputs;
    keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    readonly navigationBehavior: ListNavigation<AccordionTriggerPattern>;
    nextKey: SignalLike<"ArrowRight" | "ArrowLeft" | "ArrowDown">;
    onFocus(event: FocusEvent): void;
    onKeydown(event: KeyboardEvent): void;
    onPointerdown(event: PointerEvent): void;
    pointerdown: SignalLike<PointerEventManager<PointerEvent>>;
    prevKey: SignalLike<"ArrowUp" | "ArrowRight" | "ArrowLeft">;
    toggle(): void;
}

// @public
export interface AccordionTriggerInputs extends Omit<ListNavigationItem & ListFocusItem, 'index'>, Omit<ExpansionItem, 'expandable'> {
    accordionGroup: SignalLike<AccordionGroupPattern>;
    accordionPanelId: SignalLike<string>;
}

// @public
export class AccordionTriggerPattern implements ListNavigationItem, ListFocusItem, ExpansionItem {
    constructor(inputs: AccordionTriggerInputs);
    readonly active: SignalLike<boolean>;
    close(): void;
    readonly controls: SignalLike<string>;
    readonly disabled: SignalLike<boolean>;
    readonly element: SignalLike<HTMLElement>;
    readonly expandable: SignalLike<boolean>;
    readonly expanded: WritableSignalLike<boolean>;
    readonly hardDisabled: SignalLike<boolean>;
    readonly id: SignalLike<string>;
    // (undocumented)
    readonly inputs: AccordionTriggerInputs;
    open(): void;
    readonly tabIndex: SignalLike<-1 | 0>;
    toggle(): void;
}

// @public (undocumented)
export class ComboboxDialogPattern {
    constructor(inputs: {
        combobox: ComboboxPattern<any, any>;
        element: SignalLike<HTMLDialogElement>;
        id: SignalLike<string>;
    });
    // (undocumented)
    id: () => string;
    // (undocumented)
    readonly inputs: {
        combobox: ComboboxPattern<any, any>;
        element: SignalLike<HTMLDialogElement>;
        id: SignalLike<string>;
    };
    // (undocumented)
    keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    // (undocumented)
    onClick(event: MouseEvent): void;
    // (undocumented)
    onKeydown(event: KeyboardEvent): void;
    // (undocumented)
    role: () => "dialog";
}

// @public
export interface ComboboxInputs<T extends ListItem<V>, V> {
    alwaysExpanded: SignalLike<boolean>;
    containerEl: SignalLike<HTMLElement | undefined>;
    disabled: SignalLike<boolean>;
    filterMode: SignalLike<'manual' | 'auto-select' | 'highlight'>;
    firstMatch: SignalLike<V | undefined>;
    inputEl: SignalLike<HTMLInputElement | undefined>;
    inputValue?: WritableSignalLike<string>;
    popupControls: SignalLike<ComboboxListboxControls<T, V> | ComboboxTreeControls<T, V> | ComboboxDialogPattern | undefined>;
    readonly: SignalLike<boolean>;
    textDirection: SignalLike<'rtl' | 'ltr'>;
}

// @public
export interface ComboboxListboxControls<T extends ListItem<V>, V> {
    activeId: SignalLike<string | undefined>;
    clearSelection: () => void;
    first: () => void;
    focus: (item: T, opts?: {
        focusElement?: boolean;
    }) => void;
    getActiveItem: () => T | undefined;
    getItem: (e: PointerEvent) => T | undefined;
    getSelectedItems: () => T[];
    id: () => string;
    items: SignalLike<T[]>;
    last: () => void;
    multi: SignalLike<boolean>;
    next: () => void;
    prev: () => void;
    role: SignalLike<'listbox' | 'tree' | 'grid'>;
    select: (item?: T) => void;
    setValue: (value: V | undefined) => void;
    toggle: (item?: T) => void;
    unfocus: () => void;
}

// @public (undocumented)
export type ComboboxListboxInputs<V> = ListboxInputs<V> & {
    combobox: SignalLike<ComboboxPattern<OptionPattern<V>, V> | undefined>;
};

// @public (undocumented)
export class ComboboxListboxPattern<V> extends ListboxPattern<V> implements ComboboxListboxControls<OptionPattern<V>, V> {
    constructor(inputs: ComboboxListboxInputs<V>);
    activeId: SignalLike<string | undefined>;
    clearSelection: () => void;
    first: () => void;
    focus: (item: OptionPattern<V>, opts?: {
        focusElement?: boolean;
    }) => void;
    getActiveItem: () => OptionPattern<V> | undefined;
    getItem: (e: PointerEvent) => OptionPattern<V> | undefined;
    getSelectedItems: () => OptionPattern<V>[];
    id: SignalLike<string>;
    // (undocumented)
    readonly inputs: ComboboxListboxInputs<V>;
    items: SignalLike<OptionPattern<V>[]>;
    last: () => void;
    multi: SignalLike<boolean>;
    next: () => void;
    onKeydown(_: KeyboardEvent): void;
    onPointerdown(_: PointerEvent): void;
    prev: () => void;
    role: SignalLike<"listbox">;
    select: (item?: OptionPattern<V>) => void;
    setDefaultState(): void;
    setValue: (value: V | undefined) => void;
    tabIndex: SignalLike<-1 | 0>;
    toggle: (item?: OptionPattern<V>) => void;
    unfocus: () => void;
}

// @public
export class ComboboxPattern<T extends ListItem<V>, V> {
    constructor(inputs: ComboboxInputs<T, V>);
    activeDescendant: SignalLike<string | null>;
    autocomplete: SignalLike<"both" | "list">;
    click: SignalLike<PointerEventManager<PointerEvent>>;
    close(opts?: {
        reset: boolean;
    }): void;
    collapseItem(): void;
    collapseKey: SignalLike<"ArrowLeft" | "ArrowRight">;
    commit(): void;
    disabled: () => boolean;
    expanded: WritableSignalLike<boolean>;
    expandItem(): void;
    expandKey: SignalLike<"ArrowLeft" | "ArrowRight">;
    first(): void;
    firstMatch: SignalLike<T | undefined>;
    hasBeenFocused: WritableSignalLike<boolean>;
    hasPopup: SignalLike<"listbox" | "tree" | "grid" | "dialog" | null>;
    highlight(): void;
    highlightedItem: WritableSignalLike<T | undefined>;
    // (undocumented)
    readonly inputs: ComboboxInputs<T, V>;
    isDeleting: boolean;
    isFocused: WritableSignalLike<boolean>;
    keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    last(): void;
    listControls: () => ComboboxListboxControls<T, V> | null | undefined;
    next(): void;
    onClick(event: MouseEvent): void;
    onFilter(): void;
    onFocusIn(): void;
    onFocusOut(event: FocusEvent): void;
    onInput(event: Event): void;
    onKeydown(event: KeyboardEvent): void;
    open(nav?: {
        first?: boolean;
        last?: boolean;
        selected?: boolean;
    }): void;
    popupId: SignalLike<string | null>;
    prev(): void;
    readonly: SignalLike<true | null>;
    select(opts?: {
        item?: T;
        commit?: boolean;
        close?: boolean;
    }): void;
    treeControls: () => ComboboxTreeControls<T, V> | null;
}

// @public (undocumented)
export interface ComboboxTreeControls<T extends ListItem<V>, V> extends ComboboxListboxControls<T, V> {
    collapseAll: () => void;
    collapseItem: () => void;
    expandAll: () => void;
    expandItem: () => void;
    isItemCollapsible: () => boolean;
    isItemExpandable: (item?: T) => boolean;
    isItemSelectable: (item?: T) => boolean;
    toggleExpansion: (item?: T) => void;
}

// @public (undocumented)
export type ComboboxTreeInputs<V> = TreeInputs<V> & {
    combobox: SignalLike<ComboboxPattern<TreeItemPattern<V>, V> | undefined>;
};

// @public (undocumented)
export class ComboboxTreePattern<V> extends TreePattern<V> implements ComboboxTreeControls<TreeItemPattern<V>, V> {
    constructor(inputs: ComboboxTreeInputs<V>);
    // (undocumented)
    activeId: SignalLike<string | undefined>;
    clearSelection: () => void;
    collapseAll: () => void;
    collapseItem: () => void;
    expandAll: () => void;
    expandItem: () => void;
    first: () => void;
    focus: (item: TreeItemPattern<V>) => void;
    getActiveItem: () => TreeItemPattern<V> | undefined;
    getItem: (e: PointerEvent) => TreeItemPattern<V> | undefined;
    getSelectedItems: () => TreeItemPattern<V>[];
    // (undocumented)
    readonly inputs: ComboboxTreeInputs<V>;
    isItemCollapsible: () => boolean;
    isItemExpandable(item?: TreeItemPattern<V> | undefined): boolean;
    isItemSelectable: (item?: TreeItemPattern<V> | undefined) => boolean;
    items: SignalLike<TreeItemPattern<V>[]>;
    last: () => void;
    next: () => void;
    onKeydown(_: KeyboardEvent): void;
    onPointerdown(_: PointerEvent): void;
    prev: () => void;
    role: () => "tree";
    select: (item?: TreeItemPattern<V>) => void;
    setDefaultState(): void;
    setValue: (value: V | undefined) => void;
    tabIndex: SignalLike<-1 | 0>;
    toggle: (item?: TreeItemPattern<V>) => void;
    toggleExpansion: (item?: TreeItemPattern<V>) => void;
    unfocus: () => void;
}

// @public (undocumented)
export function computed<T>(computation: () => T): SignalLike<T>;

// @public
export function convertGetterSetterToWritableSignalLike<T>(getter: () => T, setter: (v: T) => void): WritableSignalLike<T>;

// @public
export class DeferredContent implements OnDestroy {
    constructor();
    // (undocumented)
    readonly deferredContentAware: _angular_core.WritableSignal<DeferredContentAware | null>;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<DeferredContent, never, never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<DeferredContent, never>;
}

// @public
export class DeferredContentAware {
    // (undocumented)
    readonly contentVisible: _angular_core.WritableSignal<boolean>;
    // (undocumented)
    readonly preserveContent: _angular_core.ModelSignal<boolean>;
    // (undocumented)
    static ɵdir: _angular_core.ɵɵDirectiveDeclaration<DeferredContentAware, never, never, { "preserveContent": { "alias": "preserveContent"; "required": false; "isSignal": true; }; }, { "preserveContent": "preserveContentChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: _angular_core.ɵɵFactoryDeclaration<DeferredContentAware, never>;
}

// @public
export interface GridCellInputs extends GridCell, Omit<ListNavigationInputs<GridCellWidgetPattern>, 'focusMode' | 'items' | 'activeItem' | 'softDisabled' | 'element'> {
    colIndex: SignalLike<number | undefined>;
    getWidget: (e: Element | null) => GridCellWidgetPattern | undefined;
    grid: SignalLike<GridPattern>;
    row: SignalLike<GridRowPattern>;
    rowIndex: SignalLike<number | undefined>;
    widgets: SignalLike<GridCellWidgetPattern[]>;
}

// @public
export class GridCellPattern implements GridCell {
    constructor(inputs: GridCellInputs);
    readonly active: SignalLike<boolean>;
    readonly activeWidget: WritableSignalLike<GridCellWidgetPattern | undefined>;
    readonly anchor: SignalLike<true | undefined>;
    readonly ariaColIndex: SignalLike<number | undefined>;
    readonly ariaRowIndex: SignalLike<number | undefined>;
    readonly ariaSelected: SignalLike<boolean | undefined>;
    readonly colSpan: SignalLike<number>;
    readonly disabled: SignalLike<boolean>;
    readonly element: SignalLike<HTMLElement>;
    focus(): void;
    readonly focusBehavior: ListFocus<GridCellWidgetPattern>;
    readonly id: SignalLike<string>;
    // (undocumented)
    readonly inputs: GridCellInputs;
    readonly isActivated: SignalLike<boolean>;
    readonly isFocused: WritableSignalLike<boolean>;
    readonly keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    readonly multiWidgetMode: SignalLike<boolean>;
    readonly navigationActivated: WritableSignalLike<boolean>;
    readonly navigationBehavior: ListNavigation<GridCellWidgetPattern>;
    readonly navigationDisabled: SignalLike<boolean>;
    readonly nextKey: SignalLike<"ArrowRight" | "ArrowLeft" | "ArrowDown">;
    onFocusIn(event: FocusEvent): void;
    onFocusOut(event: FocusEvent): void;
    onKeydown(event: KeyboardEvent): void;
    readonly prevKey: SignalLike<"ArrowUp" | "ArrowRight" | "ArrowLeft">;
    readonly rowSpan: SignalLike<number>;
    readonly selectable: SignalLike<boolean>;
    readonly selected: WritableSignalLike<boolean>;
    readonly singleWidgetMode: SignalLike<boolean>;
    startNavigation(): void;
    stopNavigation(): void;
    readonly tabIndex: SignalLike<-1 | 0>;
    readonly widgetActivated: SignalLike<boolean>;
    widgetTabIndex(): -1 | 0;
}

// @public
export interface GridCellWidgetInputs extends Omit<ListNavigationItem, 'index'> {
    cell: SignalLike<GridCellPattern>;
    element: SignalLike<HTMLElement>;
    focusTarget: SignalLike<HTMLElement | undefined>;
    widgetType: SignalLike<'simple' | 'complex' | 'editable'>;
}

// @public
export class GridCellWidgetPattern implements ListNavigationItem {
    constructor(inputs: GridCellWidgetInputs);
    activate(event?: KeyboardEvent | FocusEvent): void;
    readonly active: SignalLike<boolean>;
    deactivate(event?: KeyboardEvent | FocusEvent): void;
    readonly disabled: SignalLike<boolean>;
    readonly element: SignalLike<HTMLElement>;
    focus(): void;
    readonly id: SignalLike<string>;
    readonly index: SignalLike<number>;
    // (undocumented)
    readonly inputs: GridCellWidgetInputs;
    readonly isActivated: WritableSignalLike<boolean>;
    readonly keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    readonly lastActivateEvent: WritableSignalLike<KeyboardEvent | FocusEvent | undefined>;
    readonly lastDeactivateEvent: WritableSignalLike<KeyboardEvent | FocusEvent | undefined>;
    onFocusIn(event: FocusEvent): void;
    onFocusOut(event: FocusEvent): void;
    onKeydown(event: KeyboardEvent): void;
    readonly tabIndex: SignalLike<-1 | 0>;
    readonly widgetHost: SignalLike<HTMLElement>;
}

// @public
export interface GridInputs extends Omit<GridInputs$1<GridCellPattern>, 'cells'> {
    element: SignalLike<HTMLElement>;
    enableRangeSelection: SignalLike<boolean>;
    enableSelection: SignalLike<boolean>;
    getCell: (e: Element | null) => GridCellPattern | undefined;
    multi: SignalLike<boolean>;
    rows: SignalLike<GridRowPattern[]>;
    selectionMode: SignalLike<'follow' | 'explicit'>;
    textDirection: SignalLike<'rtl' | 'ltr'>;
}

// @public
export class GridPattern {
    constructor(inputs: GridInputs);
    readonly acceptsPointerMove: SignalLike<boolean>;
    readonly activeCell: SignalLike<GridCellPattern | undefined>;
    readonly activeDescendant: SignalLike<string | undefined>;
    readonly anchorCell: SignalLike<GridCellPattern | undefined>;
    readonly cells: SignalLike<GridCellPattern[][]>;
    readonly disabled: SignalLike<boolean>;
    readonly dragging: WritableSignalLike<boolean>;
    focusEffect(): void;
    readonly gridBehavior: Grid<GridCellPattern>;
    readonly hasBeenFocused: WritableSignalLike<boolean>;
    // (undocumented)
    readonly inputs: GridInputs;
    readonly isFocused: WritableSignalLike<boolean>;
    readonly keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    readonly nextColKey: SignalLike<"ArrowRight" | "ArrowLeft">;
    onFocusIn(event: FocusEvent): void;
    onFocusOut(event: FocusEvent): void;
    onKeydown(event: KeyboardEvent): void;
    onPointerdown(event: PointerEvent): void;
    onPointermove(event: PointerEvent): void;
    onPointerup(event: PointerEvent): void;
    readonly pauseNavigation: SignalLike<boolean>;
    readonly pointerdown: SignalLike<PointerEventManager<PointerEvent>>;
    readonly pointerup: SignalLike<PointerEventManager<PointerEvent>>;
    readonly prevColKey: SignalLike<"ArrowRight" | "ArrowLeft">;
    resetFocusEffect(): void;
    resetStateEffect(): void;
    restoreFocusEffect(): void;
    setDefaultStateEffect(): void;
    readonly tabIndex: SignalLike<0 | -1>;
}

// @public
export interface GridRowInputs {
    cells: SignalLike<GridCellPattern[]>;
    grid: SignalLike<GridPattern>;
    rowIndex: SignalLike<number | undefined>;
}

// @public
export class GridRowPattern {
    constructor(inputs: GridRowInputs);
    // (undocumented)
    readonly inputs: GridRowInputs;
    rowIndex: SignalLike<number | undefined>;
}

// @public (undocumented)
export function linkedSignal<T>(sourceFn: () => T): WritableSignalLike<T>;

// @public
export type ListboxInputs<V> = ListInputs<OptionPattern<V>, V> & {
    id: SignalLike<string>;
    readonly: SignalLike<boolean>;
};

// @public
export class ListboxPattern<V> {
    constructor(inputs: ListboxInputs<V>);
    activeDescendant: SignalLike<string | undefined>;
    disabled: SignalLike<boolean>;
    dynamicSpaceKey: SignalLike<"" | " ">;
    followFocus: SignalLike<boolean>;
    // (undocumented)
    protected _getItem(e: PointerEvent): OptionPattern<V> | undefined;
    // (undocumented)
    readonly inputs: ListboxInputs<V>;
    keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    // (undocumented)
    listBehavior: List<OptionPattern<V>, V>;
    multi: SignalLike<boolean>;
    nextKey: SignalLike<"ArrowRight" | "ArrowLeft" | "ArrowDown">;
    onKeydown(event: KeyboardEvent): void;
    // (undocumented)
    onPointerdown(event: PointerEvent): void;
    orientation: SignalLike<'vertical' | 'horizontal'>;
    pointerdown: SignalLike<PointerEventManager<PointerEvent>>;
    prevKey: SignalLike<"ArrowUp" | "ArrowRight" | "ArrowLeft">;
    readonly: SignalLike<boolean>;
    setDefaultState(): void;
    setsize: SignalLike<number>;
    tabIndex: SignalLike<-1 | 0>;
    typeaheadRegexp: RegExp;
    validate(): string[];
    wrap: WritableSignalLike<boolean>;
}

// @public
export interface MenuBarInputs<V> extends ListInputs<MenuItemPattern<V>, V> {
    items: SignalLike<MenuItemPattern<V>[]>;
    itemSelected?: (value: V) => void;
    textDirection: SignalLike<'ltr' | 'rtl'>;
}

// @public
export class MenuBarPattern<V> {
    constructor(inputs: MenuBarInputs<V>);
    close(): void;
    disabled: () => boolean;
    dynamicSpaceKey: SignalLike<"" | " ">;
    goto(item: MenuItemPattern<V>, opts?: {
        focusElement?: boolean;
    }): void;
    hasBeenFocused: WritableSignalLike<boolean>;
    // (undocumented)
    readonly inputs: MenuBarInputs<V>;
    isFocused: WritableSignalLike<boolean>;
    keydownManager: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    listBehavior: List<MenuItemPattern<V>, V>;
    next(): void;
    onClick(event: MouseEvent): void;
    onFocusIn(): void;
    onFocusOut(event: FocusEvent): void;
    onKeydown(event: KeyboardEvent): void;
    onMouseOver(event: MouseEvent): void;
    prev(): void;
    setDefaultState(): void;
    tabIndex: () => 0 | -1;
    typeaheadRegexp: RegExp;
}

// @public
export interface MenuInputs<V> extends Omit<ListInputs<MenuItemPattern<V>, V>, 'values'> {
    expansionDelay: SignalLike<number>;
    id: SignalLike<string>;
    items: SignalLike<MenuItemPattern<V>[]>;
    itemSelected?: (value: V) => void;
    parent: SignalLike<MenuTriggerPattern<V> | MenuItemPattern<V> | undefined>;
    textDirection: SignalLike<'ltr' | 'rtl'>;
}

// @public
export interface MenuItemInputs<V> extends Omit<ListItem<V>, 'index' | 'selectable'> {
    parent: SignalLike<MenuPattern<V> | MenuBarPattern<V> | undefined>;
    submenu: SignalLike<MenuPattern<V> | undefined>;
}

// @public
export class MenuItemPattern<V> implements ListItem<V> {
    constructor(inputs: MenuItemInputs<V>);
    active: SignalLike<boolean>;
    close(opts?: {
        refocus?: boolean;
    }): void;
    controls: WritableSignalLike<string | undefined>;
    disabled: () => boolean;
    element: SignalLike<HTMLElement | undefined>;
    expanded: SignalLike<boolean | null>;
    _expanded: WritableSignalLike<boolean>;
    hasBeenFocused: WritableSignalLike<boolean>;
    hasPopup: SignalLike<boolean>;
    id: SignalLike<string>;
    index: SignalLike<number>;
    // (undocumented)
    readonly inputs: MenuItemInputs<V>;
    onFocusIn(): void;
    open(opts?: {
        first?: boolean;
        last?: boolean;
    }): void;
    role: () => string;
    searchTerm: SignalLike<string>;
    selectable: SignalLike<boolean>;
    submenu: SignalLike<MenuPattern<V> | undefined>;
    tabIndex: SignalLike<0 | -1>;
    value: SignalLike<V>;
}

// @public
export class MenuPattern<V> {
    constructor(inputs: MenuInputs<V>);
    _clearCloseTimeout(): void;
    _clearOpenTimeout(): void;
    _clearTimeouts(): void;
    close(): void;
    closeAll(): void;
    _closeTimeout: any;
    collapse(): void;
    disabled: () => boolean;
    dynamicSpaceKey: SignalLike<"" | " ">;
    expand(): void;
    first(): void;
    hasBeenFocused: WritableSignalLike<boolean>;
    hasBeenHovered: WritableSignalLike<boolean>;
    id: SignalLike<string>;
    // (undocumented)
    readonly inputs: MenuInputs<V>;
    isFocused: WritableSignalLike<boolean>;
    keydownManager: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    last(): void;
    listBehavior: List<MenuItemPattern<V>, V>;
    next(): void;
    onClick(event: MouseEvent): void;
    onFocusIn(): void;
    onFocusOut(event: FocusEvent): void;
    onKeydown(event: KeyboardEvent): void;
    onMouseOut(event: MouseEvent): void;
    onMouseOver(event: MouseEvent): void;
    _openTimeout: any;
    prev(): void;
    role: () => string;
    root: SignalLike<MenuTriggerPattern<V> | MenuBarPattern<V> | MenuPattern<V> | undefined>;
    setDefaultState(): void;
    shouldFocus: SignalLike<boolean>;
    submit(item?: MenuItemPattern<V> | undefined): void;
    tabIndex: () => 0 | -1;
    trigger(): void;
    typeaheadRegexp: RegExp;
    visible: SignalLike<boolean>;
}

// @public
export interface MenuTriggerInputs<V> {
    disabled: SignalLike<boolean>;
    element: SignalLike<HTMLElement | undefined>;
    menu: SignalLike<MenuPattern<V> | undefined>;
    textDirection: SignalLike<'ltr' | 'rtl'>;
}

// @public
export class MenuTriggerPattern<V> {
    constructor(inputs: MenuTriggerInputs<V>);
    close(opts?: {
        refocus?: boolean;
    }): void;
    disabled: () => boolean;
    expanded: WritableSignalLike<boolean>;
    hasBeenFocused: WritableSignalLike<boolean>;
    hasPopup: () => boolean;
    // (undocumented)
    readonly inputs: MenuTriggerInputs<V>;
    keydownManager: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    menu: SignalLike<MenuPattern<V> | undefined>;
    onClick(): void;
    onFocusIn(): void;
    onFocusOut(event: FocusEvent): void;
    onKeydown(event: KeyboardEvent): void;
    open(opts?: {
        first?: boolean;
        last?: boolean;
    }): void;
    role: () => string;
    tabIndex: SignalLike<-1 | 0>;
}

// @public
export interface OptionInputs<V> extends Omit<ListItem<V>, 'index' | 'selectable'> {
    // (undocumented)
    listbox: SignalLike<ListboxPattern$1<V> | undefined>;
}

// @public
export class OptionPattern<V> {
    constructor(args: OptionInputs<V>);
    active: SignalLike<boolean>;
    disabled: SignalLike<boolean>;
    element: SignalLike<HTMLElement | undefined>;
    id: SignalLike<string>;
    index: SignalLike<number>;
    listbox: SignalLike<ListboxPattern$1<V> | undefined>;
    searchTerm: SignalLike<string>;
    selectable: () => boolean;
    selected: SignalLike<boolean | undefined>;
    tabIndex: SignalLike<0 | -1 | undefined>;
    value: SignalLike<V>;
}

// @public (undocumented)
export function signal<T>(initialValue: T): WritableSignalLike<T>;

// @public (undocumented)
export type SignalLike<T> = () => T;

// @public
export interface TabInputs extends Omit<ListNavigationItem, 'index'>, Omit<ExpansionItem, 'expandable'> {
    tablist: SignalLike<TabListPattern>;
    tabpanel: SignalLike<TabPanelPattern | undefined>;
    value: SignalLike<string>;
}

// @public
export interface TabListInputs extends Omit<ListNavigationInputs<TabPattern>, 'multi'>, Omit<ListExpansionInputs, 'multiExpandable' | 'items'> {
    selectionMode: SignalLike<'follow' | 'explicit'>;
}

// @public
export class TabListPattern {
    constructor(inputs: TabListInputs);
    readonly activeDescendant: SignalLike<string | undefined>;
    readonly activeTab: SignalLike<TabPattern | undefined>;
    readonly disabled: SignalLike<boolean>;
    readonly expansionBehavior: ListExpansion;
    readonly focusBehavior: ListFocus<TabPattern>;
    readonly followFocus: SignalLike<boolean>;
    // (undocumented)
    readonly inputs: TabListInputs;
    readonly keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    readonly navigationBehavior: ListNavigation<TabPattern>;
    readonly nextKey: SignalLike<"ArrowRight" | "ArrowLeft" | "ArrowDown">;
    onKeydown(event: KeyboardEvent): void;
    onPointerdown(event: PointerEvent): void;
    open(value: string): boolean;
    open(tab?: TabPattern): boolean;
    readonly orientation: SignalLike<'vertical' | 'horizontal'>;
    readonly pointerdown: SignalLike<PointerEventManager<PointerEvent>>;
    readonly prevKey: SignalLike<"ArrowUp" | "ArrowRight" | "ArrowLeft">;
    readonly selectedTab: WritableSignalLike<TabPattern | undefined>;
    setDefaultState(): void;
    readonly tabIndex: SignalLike<0 | -1>;
}

// @public
export interface TabPanelInputs extends LabelControlOptionalInputs {
    id: SignalLike<string>;
    tab: SignalLike<TabPattern | undefined>;
    value: SignalLike<string>;
}

// @public
export class TabPanelPattern {
    constructor(inputs: TabPanelInputs);
    readonly hidden: SignalLike<boolean>;
    readonly id: SignalLike<string>;
    // (undocumented)
    readonly inputs: TabPanelInputs;
    readonly labelledBy: SignalLike<string | undefined>;
    readonly labelManager: LabelControl;
    readonly tabIndex: SignalLike<-1 | 0>;
    readonly value: SignalLike<string>;
}

// @public
export class TabPattern {
    constructor(inputs: TabInputs);
    readonly active: SignalLike<boolean>;
    readonly controls: SignalLike<string | undefined>;
    readonly disabled: SignalLike<boolean>;
    readonly element: SignalLike<HTMLElement>;
    readonly expandable: SignalLike<boolean>;
    readonly expanded: WritableSignalLike<boolean>;
    readonly id: SignalLike<string>;
    readonly index: SignalLike<number>;
    // (undocumented)
    readonly inputs: TabInputs;
    open(): boolean;
    readonly selected: SignalLike<boolean>;
    readonly tabIndex: SignalLike<0 | -1>;
    readonly value: SignalLike<string>;
}

// @public
export type ToolbarInputs<V> = Omit<ListInputs<ToolbarWidgetPattern<V>, V>, 'multi' | 'typeaheadDelay' | 'selectionMode' | 'focusMode'> & {
    getItem: (e: Element) => ToolbarWidgetPattern<V> | undefined;
};

// @public
export class ToolbarPattern<V> {
    constructor(inputs: ToolbarInputs<V>);
    readonly activeDescendant: SignalLike<string | undefined>;
    readonly activeItem: () => ToolbarWidgetPattern<V> | undefined;
    readonly disabled: SignalLike<boolean>;
    // (undocumented)
    readonly inputs: ToolbarInputs<V>;
    readonly listBehavior: List<ToolbarWidgetPattern<V>, V>;
    onClick(event: MouseEvent): void;
    onKeydown(event: KeyboardEvent): void;
    // (undocumented)
    onPointerdown(event: PointerEvent): void;
    readonly orientation: SignalLike<'vertical' | 'horizontal'>;
    // (undocumented)
    select(): void;
    setDefaultState(): void;
    readonly softDisabled: SignalLike<boolean>;
    readonly tabIndex: SignalLike<0 | -1>;
}

// @public
export interface ToolbarWidgetGroupInputs<T extends ListItem<V>, V> {
    disabled: SignalLike<boolean>;
    items: SignalLike<T[]>;
    multi: SignalLike<boolean>;
    toolbar: SignalLike<ToolbarPattern<V> | undefined>;
}

// @public
export class ToolbarWidgetGroupPattern<T extends ListItem<V>, V> {
    constructor(inputs: ToolbarWidgetGroupInputs<T, V>);
    readonly disabled: () => boolean;
    // (undocumented)
    readonly element: () => undefined;
    // (undocumented)
    readonly inputs: ToolbarWidgetGroupInputs<T, V>;
    readonly multi: () => boolean;
    // (undocumented)
    readonly searchTerm: () => string;
    // (undocumented)
    readonly selectable: () => boolean;
    readonly toolbar: () => ToolbarPattern<V> | undefined;
    // (undocumented)
    readonly value: () => V;
}

// @public
export interface ToolbarWidgetInputs<V> extends Omit<ListItem<V>, 'searchTerm' | 'index' | 'selectable'> {
    group: SignalLike<ToolbarWidgetGroupPattern<ToolbarWidgetPattern<V>, V> | undefined>;
    toolbar: SignalLike<ToolbarPattern<V>>;
}

// @public (undocumented)
export class ToolbarWidgetPattern<V> implements ListItem<V> {
    constructor(inputs: ToolbarWidgetInputs<V>);
    readonly active: SignalLike<boolean>;
    readonly disabled: () => boolean;
    readonly element: () => HTMLElement | undefined;
    readonly group: () => ToolbarWidgetGroupPattern<ToolbarWidgetPattern<V>, V> | undefined;
    readonly id: () => string;
    readonly index: SignalLike<number>;
    // (undocumented)
    readonly inputs: ToolbarWidgetInputs<V>;
    readonly searchTerm: () => string;
    readonly selectable: () => boolean;
    readonly selected: SignalLike<boolean>;
    readonly tabIndex: SignalLike<0 | -1>;
    readonly toolbar: () => ToolbarPattern<V>;
    readonly value: () => V;
}

// @public
export interface TreeInputs<V> extends Omit<TreeInputs$1<TreeItemPattern<V>, V>, 'multiExpandable'> {
    currentType: SignalLike<'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'>;
    id: SignalLike<string>;
    nav: SignalLike<boolean>;
    textDirection: SignalLike<'ltr' | 'rtl'>;
}

// @public
export interface TreeItemInputs<V> extends Omit<TreeItem<V, TreeItemPattern<V>>, 'index' | 'parent' | 'visible' | 'expandable'> {
    hasChildren: SignalLike<boolean>;
    parent: SignalLike<TreeItemPattern<V> | TreePattern<V>>;
    tree: SignalLike<TreePattern<V>>;
}

// @public
export class TreeItemPattern<V> implements TreeItem<V, TreeItemPattern<V>> {
    constructor(inputs: TreeItemInputs<V>);
    readonly active: SignalLike<boolean>;
    readonly children: SignalLike<TreeItemPattern<V>[]>;
    readonly current: SignalLike<string | undefined>;
    readonly disabled: SignalLike<boolean>;
    readonly element: SignalLike<HTMLElement>;
    readonly expandable: SignalLike<boolean>;
    readonly expanded: WritableSignalLike<boolean>;
    readonly id: SignalLike<string>;
    readonly index: SignalLike<number>;
    // (undocumented)
    readonly inputs: TreeItemInputs<V>;
    readonly level: SignalLike<number>;
    readonly parent: SignalLike<TreeItemPattern<V> | undefined>;
    readonly posinset: SignalLike<number>;
    readonly searchTerm: SignalLike<string>;
    readonly selectable: SignalLike<boolean>;
    readonly selected: SignalLike<boolean | undefined>;
    readonly setsize: SignalLike<number>;
    readonly tabIndex: SignalLike<0 | -1>;
    readonly tree: SignalLike<TreePattern<V>>;
    readonly value: SignalLike<V>;
    readonly visible: SignalLike<boolean>;
}

// @public
export class TreePattern<V> implements TreeInputs<V> {
    constructor(inputs: TreeInputs<V>);
    readonly activeDescendant: SignalLike<string | undefined>;
    readonly activeItem: WritableSignalLike<TreeItemPattern<V> | undefined>;
    readonly children: SignalLike<TreeItemPattern<V>[]>;
    readonly collapseKey: SignalLike<"ArrowUp" | "ArrowRight" | "ArrowLeft">;
    _collapseOrParent(opts?: SelectOptions): void;
    readonly currentType: SignalLike<'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'>;
    readonly disabled: SignalLike<boolean>;
    readonly dynamicSpaceKey: SignalLike<"" | " ">;
    readonly element: SignalLike<HTMLElement>;
    readonly expanded: () => boolean;
    readonly expandKey: SignalLike<"ArrowRight" | "ArrowLeft" | "ArrowDown">;
    _expandOrFirstChild(opts?: SelectOptions): void;
    readonly focusMode: SignalLike<'roving' | 'activedescendant'>;
    readonly followFocus: SignalLike<boolean>;
    protected _getItem(event: Event): TreeItemPattern<V> | undefined;
    goto(e: PointerEvent, opts?: SelectOptions): void;
    readonly id: SignalLike<string>;
    // (undocumented)
    readonly inputs: TreeInputs<V>;
    readonly isRtl: SignalLike<boolean>;
    readonly items: SignalLike<TreeItemPattern<V>[]>;
    readonly keydown: SignalLike<KeyboardEventManager<KeyboardEvent>>;
    readonly level: () => number;
    readonly multi: SignalLike<boolean>;
    readonly nav: SignalLike<boolean>;
    readonly nextKey: SignalLike<"ArrowRight" | "ArrowLeft" | "ArrowDown">;
    onKeydown(event: KeyboardEvent): void;
    onPointerdown(event: PointerEvent): void;
    readonly orientation: SignalLike<'vertical' | 'horizontal'>;
    pointerdown: SignalLike<PointerEventManager<PointerEvent>>;
    readonly prevKey: SignalLike<"ArrowUp" | "ArrowRight" | "ArrowLeft">;
    readonly selectionMode: SignalLike<'follow' | 'explicit'>;
    setDefaultState(): void;
    readonly softDisabled: SignalLike<boolean>;
    readonly tabIndex: SignalLike<-1 | 0>;
    readonly textDirection: SignalLike<'ltr' | 'rtl'>;
    readonly treeBehavior: Tree<TreeItemPattern<V>, V>;
    readonly typeaheadDelay: SignalLike<number>;
    readonly typeaheadRegexp: RegExp;
    validate(): string[];
    readonly values: WritableSignalLike<V[]>;
    readonly visible: () => boolean;
    readonly wrap: SignalLike<boolean>;
}

export { untracked }

// @public (undocumented)
export interface WritableSignalLike<T> extends SignalLike<T> {
    // (undocumented)
    asReadonly(): SignalLike<T>;
    // (undocumented)
    set(value: T): void;
    // (undocumented)
    update(updateFn: (value: T) => T): void;
}

// (No @packageDocumentation comment for this package)

```
