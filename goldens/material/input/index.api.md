## API Report File for "@angular/material_input"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { AbstractControlDirective } from '@angular/forms';
import { AfterContentChecked } from '@angular/core';
import { AfterContentInit } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { BooleanInput } from '@angular/cdk/coercion';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { FormGroupDirective } from '@angular/forms';
import * as i0 from '@angular/core';
import * as i1 from '@angular/cdk/bidi';
import * as i2 from '@angular/cdk/observers';
import * as i4 from '@angular/cdk/text-field';
import { InjectionToken } from '@angular/core';
import { NgControl } from '@angular/forms';
import { NgForm } from '@angular/forms';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { Platform } from '@angular/cdk/platform';
import { QueryList } from '@angular/core';
import { Subject } from 'rxjs';
import { WritableSignal } from '@angular/core';

// @public
export function getMatInputUnsupportedTypeError(type: string): Error;

// @public
export const MAT_INPUT_CONFIG: InjectionToken<MatInputConfig>;

// @public
export const MAT_INPUT_VALUE_ACCESSOR: InjectionToken<{
    value: any | WritableSignal<any>;
}>;

// @public
export class MatError {
    constructor(...args: unknown[]);
    // (undocumented)
    id: string;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatError, "mat-error, [matError]", never, { "id": { "alias": "id"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatError, never>;
}

// @public
export class MatFormField implements FloatingLabelParent, AfterContentInit, AfterContentChecked, AfterViewInit, OnDestroy {
    constructor(...args: unknown[]);
    _animateAndLockLabel(): void;
    // (undocumented)
    protected readonly _animationsDisabled: boolean;
    get appearance(): MatFormFieldAppearance;
    set appearance(value: MatFormFieldAppearance);
    color: ThemePalette;
    get _control(): MatFormFieldControl<any>;
    set _control(value: MatFormFieldControl<any>);
    // (undocumented)
    _elementRef: ElementRef<any>;
    // (undocumented)
    _errorChildren: QueryList<MatError>;
    // (undocumented)
    _floatingLabel: MatFormFieldFloatingLabel | undefined;
    get floatLabel(): FloatLabelType;
    set floatLabel(value: FloatLabelType);
    _forceDisplayInfixLabel(): boolean | 0;
    // (undocumented)
    _formFieldControl: MatFormFieldControl<any>;
    getConnectedOverlayOrigin(): ElementRef;
    getLabelId: i0.Signal<string | null>;
    _getSubscriptMessageType(): 'error' | 'hint';
    _handleLabelResized(): void;
    // (undocumented)
    _hasFloatingLabel: i0.Signal<boolean>;
    // (undocumented)
    _hasIconPrefix: boolean;
    // (undocumented)
    _hasIconSuffix: boolean;
    // (undocumented)
    _hasOutline(): boolean;
    // (undocumented)
    _hasTextPrefix: boolean;
    // (undocumented)
    _hasTextSuffix: boolean;
    get hideRequiredMarker(): boolean;
    set hideRequiredMarker(value: BooleanInput);
    // (undocumented)
    _hintChildren: QueryList<MatHint>;
    get hintLabel(): string;
    set hintLabel(value: string);
    // (undocumented)
    readonly _hintLabelId: string;
    // (undocumented)
    _iconPrefixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    _iconSuffixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    readonly _labelId: string;
    // (undocumented)
    _lineRipple: MatFormFieldLineRipple | undefined;
    // (undocumented)
    ngAfterContentChecked(): void;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _notchedOutline: MatFormFieldNotchedOutline | undefined;
    // (undocumented)
    _prefixChildren: QueryList<MatPrefix>;
    _refreshOutlineNotchWidth(): void;
    _shouldAlwaysFloat(): boolean;
    _shouldForward(prop: keyof AbstractControlDirective): boolean;
    // (undocumented)
    _shouldLabelFloat(): boolean;
    get subscriptSizing(): SubscriptSizing;
    set subscriptSizing(value: SubscriptSizing);
    // (undocumented)
    _suffixChildren: QueryList<MatSuffix>;
    // (undocumented)
    _textField: ElementRef<HTMLElement>;
    // (undocumented)
    _textPrefixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    _textSuffixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatFormField, "mat-form-field", ["matFormField"], { "hideRequiredMarker": { "alias": "hideRequiredMarker"; "required": false; }; "color": { "alias": "color"; "required": false; }; "floatLabel": { "alias": "floatLabel"; "required": false; }; "appearance": { "alias": "appearance"; "required": false; }; "subscriptSizing": { "alias": "subscriptSizing"; "required": false; }; "hintLabel": { "alias": "hintLabel"; "required": false; }; }, {}, ["_labelChild", "_formFieldControl", "_prefixChildren", "_suffixChildren", "_errorChildren", "_hintChildren"], ["mat-label", "[matPrefix], [matIconPrefix]", "[matTextPrefix]", "*", "[matTextSuffix]", "[matSuffix], [matIconSuffix]", "mat-error, [matError]", "mat-hint:not([align='end'])", "mat-hint[align='end']"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatFormField, never>;
}

// @public
export class MatHint {
    align: 'start' | 'end';
    id: string;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatHint, "mat-hint", never, { "align": { "alias": "align"; "required": false; }; "id": { "alias": "id"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatHint, never>;
}

// @public (undocumented)
export class MatInput implements MatFormFieldControl_2<any>, OnChanges, OnDestroy, AfterViewInit, DoCheck {
    constructor(...args: unknown[]);
    autofilled: boolean;
    controlType: string;
    protected _dirtyCheckNativeValue(): void;
    get disabled(): boolean;
    set disabled(value: BooleanInput);
    // (undocumented)
    protected _disabled: boolean;
    disabledInteractive: boolean;
    // (undocumented)
    protected _elementRef: ElementRef<HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement>;
    get empty(): boolean;
    get errorState(): boolean;
    set errorState(value: boolean);
    get errorStateMatcher(): ErrorStateMatcher;
    set errorStateMatcher(value: ErrorStateMatcher);
    focus(options?: FocusOptions): void;
    _focusChanged(isFocused: boolean): void;
    focused: boolean;
    // (undocumented)
    protected _formField?: MatFormField | null | undefined;
    protected _getPlaceholder(): string | null;
    protected _getReadonlyAttribute(): string | null;
    get id(): string;
    set id(value: string);
    // (undocumented)
    protected _id: string;
    protected _isBadInput(): boolean;
    readonly _isInFormField: boolean;
    _isInlineSelect(): boolean;
    readonly _isNativeSelect: boolean;
    protected _isNeverEmpty(): boolean;
    readonly _isServer: boolean;
    readonly _isTextarea: boolean;
    name: string;
    // (undocumented)
    protected _neverEmptyInputTypes: string[];
    // (undocumented)
    static ngAcceptInputType_disabledInteractive: unknown;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngControl: NgControl;
    // (undocumented)
    ngDoCheck(): void;
    // (undocumented)
    ngOnChanges(): void;
    // (undocumented)
    ngOnDestroy(): void;
    onContainerClick(): void;
    // (undocumented)
    _onInput(): void;
    placeholder: string;
    // (undocumented)
    protected _platform: Platform;
    // (undocumented)
    protected _previousNativeValue: any;
    get readonly(): boolean;
    set readonly(value: BooleanInput);
    get required(): boolean;
    set required(value: BooleanInput);
    // (undocumented)
    protected _required: boolean | undefined;
    setDescribedByIds(ids: string[]): void;
    get shouldLabelFloat(): boolean;
    readonly stateChanges: Subject<void>;
    get type(): string;
    set type(value: string);
    // (undocumented)
    protected _type: string;
    // (undocumented)
    protected _uid: string;
    updateErrorState(): void;
    userAriaDescribedBy: string;
    protected _validateType(): void;
    get value(): string;
    set value(value: any);
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatInput, "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", ["matInput"], { "disabled": { "alias": "disabled"; "required": false; }; "id": { "alias": "id"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "name": { "alias": "name"; "required": false; }; "required": { "alias": "required"; "required": false; }; "type": { "alias": "type"; "required": false; }; "errorStateMatcher": { "alias": "errorStateMatcher"; "required": false; }; "userAriaDescribedBy": { "alias": "aria-describedby"; "required": false; }; "value": { "alias": "value"; "required": false; }; "readonly": { "alias": "readonly"; "required": false; }; "disabledInteractive": { "alias": "disabledInteractive"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatInput, never>;
}

// @public
export interface MatInputConfig {
    disabledInteractive?: boolean;
}

// @public (undocumented)
export class MatInputModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatInputModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatInputModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatInputModule, never, [typeof MatCommonModule, typeof MatFormFieldModule, typeof MatInput], [typeof MatInput, typeof MatFormFieldModule, typeof i4.TextFieldModule, typeof MatCommonModule]>;
}

// @public
export class MatLabel {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatLabel, "mat-label", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatLabel, never>;
}

// @public
export class MatPrefix {
    // (undocumented)
    _isText: boolean;
    // (undocumented)
    set _isTextSelector(value: '');
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatPrefix, "[matPrefix], [matIconPrefix], [matTextPrefix]", never, { "_isTextSelector": { "alias": "matTextPrefix"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatPrefix, never>;
}

// @public
export class MatSuffix {
    // (undocumented)
    _isText: boolean;
    // (undocumented)
    set _isTextSelector(value: '');
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatSuffix, "[matSuffix], [matIconSuffix], [matTextSuffix]", never, { "_isTextSelector": { "alias": "matTextSuffix"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatSuffix, never>;
}

// (No @packageDocumentation comment for this package)

```
