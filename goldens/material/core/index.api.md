## API Report File for "@angular/material_core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { AfterViewChecked } from '@angular/core';
import { ChangeDetectorRef } from '@angular/core';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import { FocusableOption } from '@angular/cdk/a11y';
import { FocusOrigin } from '@angular/cdk/a11y';
import { FormGroupDirective } from '@angular/forms';
import * as i0 from '@angular/core';
import * as i1 from '@angular/cdk/bidi';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { NgControl } from '@angular/forms';
import { NgForm } from '@angular/forms';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Platform } from '@angular/cdk/platform';
import { Provider } from '@angular/core';
import { QueryList } from '@angular/core';
import { Signal } from '@angular/core';
import { Subject } from 'rxjs';
import { Version } from '@angular/core';

// @public @deprecated (undocumented)
export class AnimationCurves {
    // (undocumented)
    static ACCELERATION_CURVE: string;
    // (undocumented)
    static DECELERATION_CURVE: string;
    // (undocumented)
    static SHARP_CURVE: string;
    // (undocumented)
    static STANDARD_CURVE: string;
}

// @public @deprecated (undocumented)
export class AnimationDurations {
    // (undocumented)
    static COMPLEX: string;
    // (undocumented)
    static ENTERING: string;
    // (undocumented)
    static EXITING: string;
}

// @public
export function _animationsDisabled(): boolean;

// @public
export function _countGroupLabelsBeforeOption(optionIndex: number, options: QueryList<MatOption>, optionGroups: QueryList<MatOptgroup>): number;

// @public
export abstract class DateAdapter<D, L = any> {
    abstract addCalendarDays(date: D, days: number): D;
    abstract addCalendarMonths(date: D, months: number): D;
    abstract addCalendarYears(date: D, years: number): D;
    addSeconds(date: D, amount: number): D;
    clampDate(date: D, min?: D | null, max?: D | null): D;
    abstract clone(date: D): D;
    compareDate(first: D, second: D): number;
    compareTime(first: D, second: D): number;
    abstract createDate(year: number, month: number, date: number): D;
    deserialize(value: any): D | null;
    abstract format(date: D, displayFormat: any): string;
    abstract getDate(date: D): number;
    abstract getDateNames(): string[];
    abstract getDayOfWeek(date: D): number;
    abstract getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];
    abstract getFirstDayOfWeek(): number;
    getHours(date: D): number;
    getMinutes(date: D): number;
    abstract getMonth(date: D): number;
    abstract getMonthNames(style: 'long' | 'short' | 'narrow'): string[];
    abstract getNumDaysInMonth(date: D): number;
    getSeconds(date: D): number;
    getValidDateOrNull(obj: unknown): D | null;
    abstract getYear(date: D): number;
    abstract getYearName(date: D): string;
    abstract invalid(): D;
    abstract isDateInstance(obj: any): boolean;
    abstract isValid(date: D): boolean;
    protected locale: L;
    readonly localeChanges: Observable<void>;
    // (undocumented)
    protected readonly _localeChanges: Subject<void>;
    abstract parse(value: any, parseFormat: any): D | null;
    parseTime(value: any, parseFormat: any): D | null;
    sameDate(first: D | null, second: D | null): boolean;
    sameTime(first: D | null, second: D | null): boolean;
    setLocale(locale: L): void;
    setTime(target: D, hours: number, minutes: number, seconds: number): D;
    abstract today(): D;
    abstract toIso8601(date: D): string;
}

// @public
export const defaultRippleAnimationConfig: {
    enterDuration: number;
    exitDuration: number;
};

// @public
export class ErrorStateMatcher {
    // (undocumented)
    isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ErrorStateMatcher, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ErrorStateMatcher>;
}

// @public
export class _ErrorStateTracker {
    constructor(_defaultMatcher: ErrorStateMatcher_2 | null, ngControl: NgControl | null, _parentFormGroup: FormGroupDirective | null, _parentForm: NgForm | null, _stateChanges: Subject<void>);
    errorState: boolean;
    matcher: ErrorStateMatcher_2;
    // (undocumented)
    ngControl: NgControl | null;
    updateErrorState(): void;
}

// @public
export function _getOptionScrollPosition(optionOffset: number, optionHeight: number, currentScrollPosition: number, panelHeight: number): number;

// @public @deprecated
export interface GranularSanityChecks {
    // (undocumented)
    doctype: boolean;
    // (undocumented)
    theme: boolean;
    // (undocumented)
    version: boolean;
}

// @public (undocumented)
export const MAT_DATE_FORMATS: InjectionToken<MatDateFormats>;

// @public
export const MAT_DATE_LOCALE: InjectionToken<{}>;

// @public @deprecated
export function MAT_DATE_LOCALE_FACTORY(): {};

// @public (undocumented)
export const MAT_NATIVE_DATE_FORMATS: MatDateFormats;

// @public
export const MAT_OPTGROUP: InjectionToken<MatOptgroup>;

// @public
export const MAT_OPTION_PARENT_COMPONENT: InjectionToken<MatOptionParentComponent>;

// @public
export const MAT_RIPPLE_GLOBAL_OPTIONS: InjectionToken<RippleGlobalOptions>;

// @public @deprecated
export class MatCommonModule {
    constructor(...args: any[]);
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatCommonModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatCommonModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatCommonModule, never, [typeof i1.BidiModule], [typeof i1.BidiModule]>;
}

// @public (undocumented)
export type MatDateFormats = {
    parse: {
        dateInput: any;
        timeInput?: any;
    };
    display: {
        dateInput: any;
        monthLabel?: any;
        monthYearLabel: any;
        dateA11yLabel: any;
        monthYearA11yLabel: any;
        timeInput?: any;
        timeOptionLabel?: any;
    };
};

// @public @deprecated
export const MATERIAL_SANITY_CHECKS: InjectionToken<SanityChecks>;

// @public
export class _MatInternalFormField {
    labelPosition: 'before' | 'after';
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<_MatInternalFormField, "div[mat-internal-form-field]", never, { "labelPosition": { "alias": "labelPosition"; "required": true; }; }, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<_MatInternalFormField, never>;
}

// @public
export class MatLine {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatLine, "[mat-line], [matLine]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatLine, never>;
}

// @public (undocumented)
export class MatLineModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatLineModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatLineModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatLineModule, never, [typeof MatCommonModule, typeof MatLine], [typeof MatLine, typeof MatCommonModule]>;
}

// @public (undocumented)
export class MatNativeDateModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatNativeDateModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatNativeDateModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatNativeDateModule, never, never, never>;
}

// @public
export class MatOptgroup {
    constructor(...args: unknown[]);
    disabled: boolean;
    _inert: boolean;
    label: string;
    _labelId: string;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatOptgroup, "mat-optgroup", ["matOptgroup"], { "label": { "alias": "label"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; }, {}, never, ["*", "mat-option, ng-container"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatOptgroup, never>;
}

// @public
export class MatOption<T = any> implements FocusableOption, AfterViewChecked, OnDestroy {
    constructor(...args: unknown[]);
    get active(): boolean;
    // (undocumented)
    _changeDetectorRef: ChangeDetectorRef;
    deselect(emitEvent?: boolean): void;
    get disabled(): boolean;
    set disabled(value: boolean);
    get disableRipple(): boolean;
    focus(_origin?: FocusOrigin, options?: FocusOptions): void;
    _getHostElement(): HTMLElement;
    getLabel(): string;
    _getTabIndex(): string;
    // (undocumented)
    group: MatOptgroup | null;
    _handleKeydown(event: KeyboardEvent): void;
    get hideSingleSelectionIndicator(): boolean;
    id: string;
    get multiple(): boolean | null | undefined;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    ngAfterViewChecked(): void;
    // (undocumented)
    ngOnDestroy(): void;
    readonly onSelectionChange: EventEmitter<MatOptionSelectionChange<T>>;
    select(emitEvent?: boolean): void;
    get selected(): boolean;
    _selectViaInteraction(): void;
    setActiveStyles(): void;
    setInactiveStyles(): void;
    readonly _stateChanges: Subject<void>;
    _text: ElementRef<HTMLElement> | undefined;
    value: T;
    get viewValue(): string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatOption<any>, "mat-option", ["matOption"], { "value": { "alias": "value"; "required": false; }; "id": { "alias": "id"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; }, { "onSelectionChange": "onSelectionChange"; }, never, ["mat-icon", "*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatOption<any>, never>;
}

// @public (undocumented)
export class MatOptionModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatOptionModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatOptionModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatOptionModule, never, [typeof MatRippleModule, typeof MatCommonModule, typeof MatPseudoCheckboxModule, typeof MatOption, typeof MatOptgroup], [typeof MatOption, typeof MatOptgroup]>;
}

// @public
export interface MatOptionParentComponent {
    // (undocumented)
    disableRipple?: boolean | Signal<boolean>;
    // (undocumented)
    hideSingleSelectionIndicator?: boolean;
    // (undocumented)
    inertGroups?: boolean;
    // (undocumented)
    multiple?: boolean;
}

// @public
export class MatOptionSelectionChange<T = any> {
    constructor(
    source: MatOption<T>,
    isUserInput?: boolean);
    isUserInput: boolean;
    source: MatOption<T>;
}

// @public
export class MatPseudoCheckbox {
    constructor(...args: unknown[]);
    // (undocumented)
    _animationsDisabled: boolean;
    appearance: 'minimal' | 'full';
    disabled: boolean;
    state: MatPseudoCheckboxState;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatPseudoCheckbox, "mat-pseudo-checkbox", never, { "state": { "alias": "state"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "appearance": { "alias": "appearance"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatPseudoCheckbox, never>;
}

// @public (undocumented)
export class MatPseudoCheckboxModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatPseudoCheckboxModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatPseudoCheckboxModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatPseudoCheckboxModule, never, [typeof MatCommonModule, typeof MatPseudoCheckbox], [typeof MatPseudoCheckbox]>;
}

// @public
export type MatPseudoCheckboxState = 'unchecked' | 'checked' | 'indeterminate';

// @public (undocumented)
export class MatRipple implements OnInit, OnDestroy, RippleTarget {
    constructor(...args: unknown[]);
    animation: RippleAnimationConfig;
    centered: boolean;
    color: string;
    get disabled(): boolean;
    set disabled(value: boolean);
    fadeOutAll(): void;
    fadeOutAllNonPersistent(): void;
    _isInitialized: boolean;
    launch(config: RippleConfig): RippleRef;
    launch(x: number, y: number, config?: RippleConfig): RippleRef;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    radius: number;
    get rippleConfig(): RippleConfig;
    get rippleDisabled(): boolean;
    get trigger(): HTMLElement;
    set trigger(trigger: HTMLElement);
    unbounded: boolean;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatRipple, "[mat-ripple], [matRipple]", ["matRipple"], { "color": { "alias": "matRippleColor"; "required": false; }; "unbounded": { "alias": "matRippleUnbounded"; "required": false; }; "centered": { "alias": "matRippleCentered"; "required": false; }; "radius": { "alias": "matRippleRadius"; "required": false; }; "animation": { "alias": "matRippleAnimation"; "required": false; }; "disabled": { "alias": "matRippleDisabled"; "required": false; }; "trigger": { "alias": "matRippleTrigger"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatRipple, never>;
}

// @public
export class MatRippleLoader implements OnDestroy {
    constructor();
    configureRipple(host: HTMLElement, config: {
        className?: string;
        centered?: boolean;
        disabled?: boolean;
    }): void;
    // (undocumented)
    destroyRipple(host: HTMLElement): void;
    // (undocumented)
    ngOnDestroy(): void;
    setDisabled(host: HTMLElement, disabled: boolean): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatRippleLoader, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatRippleLoader>;
}

// @public (undocumented)
export class MatRippleModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatRippleModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatRippleModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatRippleModule, never, [typeof MatCommonModule, typeof MatRipple], [typeof MatRipple, typeof MatCommonModule]>;
}

// @public
export class NativeDateAdapter extends DateAdapter<Date> {
    constructor(...args: unknown[]);
    // (undocumented)
    addCalendarDays(date: Date, days: number): Date;
    // (undocumented)
    addCalendarMonths(date: Date, months: number): Date;
    // (undocumented)
    addCalendarYears(date: Date, years: number): Date;
    // (undocumented)
    addSeconds(date: Date, amount: number): Date;
    // (undocumented)
    clone(date: Date): Date;
    // (undocumented)
    createDate(year: number, month: number, date: number): Date;
    deserialize(value: any): Date | null;
    // (undocumented)
    format(date: Date, displayFormat: Object): string;
    // (undocumented)
    getDate(date: Date): number;
    // (undocumented)
    getDateNames(): string[];
    // (undocumented)
    getDayOfWeek(date: Date): number;
    // (undocumented)
    getDayOfWeekNames(style: 'long' | 'short' | 'narrow'): string[];
    // (undocumented)
    getFirstDayOfWeek(): number;
    // (undocumented)
    getHours(date: Date): number;
    // (undocumented)
    getMinutes(date: Date): number;
    // (undocumented)
    getMonth(date: Date): number;
    // (undocumented)
    getMonthNames(style: 'long' | 'short' | 'narrow'): string[];
    // (undocumented)
    getNumDaysInMonth(date: Date): number;
    // (undocumented)
    getSeconds(date: Date): number;
    // (undocumented)
    getYear(date: Date): number;
    // (undocumented)
    getYearName(date: Date): string;
    // (undocumented)
    invalid(): Date;
    // (undocumented)
    isDateInstance(obj: any): obj is Date;
    // (undocumented)
    isValid(date: Date): boolean;
    // (undocumented)
    parse(value: any, parseFormat?: any): Date | null;
    // (undocumented)
    parseTime(userValue: any, parseFormat?: any): Date | null;
    // (undocumented)
    setTime(target: Date, hours: number, minutes: number, seconds: number): Date;
    // (undocumented)
    today(): Date;
    // (undocumented)
    toIso8601(date: Date): string;
    // @deprecated (undocumented)
    useUtcForDisplay: boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NativeDateAdapter, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<NativeDateAdapter>;
}

// @public (undocumented)
export class NativeDateModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NativeDateModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<NativeDateModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<NativeDateModule, never, never, never>;
}

// @public (undocumented)
export function provideNativeDateAdapter(formats?: MatDateFormats): Provider[];

// @public
export interface RippleAnimationConfig {
    enterDuration?: number;
    exitDuration?: number;
}

// @public (undocumented)
export type RippleConfig = {
    color?: string;
    centered?: boolean;
    radius?: number;
    persistent?: boolean;
    animation?: RippleAnimationConfig;
    terminateOnPointerUp?: boolean;
};

// @public
export interface RippleGlobalOptions {
    animation?: RippleAnimationConfig;
    disabled?: boolean;
    namespace?: string;
    terminateOnPointerUp?: boolean;
}

// @public
export class RippleRef {
    constructor(_renderer: {
        fadeOutRipple(ref: RippleRef): void;
    },
    element: HTMLElement,
    config: RippleConfig, _animationForciblyDisabledThroughCss?: boolean);
    // (undocumented)
    _animationForciblyDisabledThroughCss: boolean;
    config: RippleConfig;
    element: HTMLElement;
    fadeOut(): void;
    state: RippleState;
}

// @public
export class RippleRenderer implements EventListenerObject {
    constructor(_target: RippleTarget, _ngZone: NgZone, elementOrElementRef: HTMLElement | ElementRef<HTMLElement>, _platform: Platform, injector?: Injector);
    fadeInRipple(x: number, y: number, config?: RippleConfig): RippleRef;
    fadeOutAll(): void;
    fadeOutAllNonPersistent(): void;
    fadeOutRipple(rippleRef: RippleRef): void;
    handleEvent(event: Event): void;
    _removeTriggerEvents(): void;
    setupTriggerEvents(elementOrElementRef: HTMLElement | ElementRef<HTMLElement>): void;
}

// @public
export enum RippleState {
    // (undocumented)
    FADING_IN = 0,
    // (undocumented)
    FADING_OUT = 2,
    // (undocumented)
    HIDDEN = 3,
    // (undocumented)
    VISIBLE = 1
}

// @public
export interface RippleTarget {
    rippleConfig: RippleConfig;
    rippleDisabled: boolean;
}

// @public @deprecated
export type SanityChecks = boolean | GranularSanityChecks;

// @public
export function setLines(lines: QueryList<unknown>, element: ElementRef<HTMLElement>, prefix?: string): void;

// @public
export class ShowOnDirtyErrorStateMatcher implements ErrorStateMatcher {
    // (undocumented)
    isErrorState(control: AbstractControl | null, form: FormGroupDirective | NgForm | null): boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ShowOnDirtyErrorStateMatcher, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ShowOnDirtyErrorStateMatcher>;
}

// @public
export class _StructuralStylesLoader {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<_StructuralStylesLoader, "structural-styles", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<_StructuralStylesLoader, never>;
}

// @public
export type ThemePalette = 'primary' | 'accent' | 'warn' | undefined;

// @public
export const VERSION: Version;

// (No @packageDocumentation comment for this package)

```
