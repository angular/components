## API Report File for "@angular/material_select"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { AbstractControlDirective } from '@angular/forms';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { AfterContentChecked } from '@angular/core';
import { AfterContentInit } from '@angular/core';
import { AfterViewChecked } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { BooleanInput } from '@angular/cdk/coercion';
import { CdkConnectedOverlay } from '@angular/cdk/overlay';
import { CdkOverlayOrigin } from '@angular/cdk/overlay';
import { ChangeDetectorRef } from '@angular/core';
import { ConnectedPosition } from '@angular/cdk/overlay';
import { ControlValueAccessor } from '@angular/forms';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import { FocusableOption } from '@angular/cdk/a11y';
import { FocusOrigin } from '@angular/cdk/a11y';
import { FormGroupDirective } from '@angular/forms';
import * as i0 from '@angular/core';
import * as i1 from '@angular/cdk/bidi';
import * as i2 from '@angular/cdk/overlay';
import * as i2_2 from '@angular/cdk/observers';
import * as i5 from '@angular/cdk/scrolling';
import { InjectionToken } from '@angular/core';
import { NgControl } from '@angular/forms';
import { NgForm } from '@angular/forms';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { QueryList } from '@angular/core';
import { ScrollStrategy } from '@angular/cdk/overlay';
import { SelectionModel } from '@angular/cdk/collections';
import { SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { ViewportRuler } from '@angular/cdk/scrolling';

// @public
export const MAT_SELECT_CONFIG: InjectionToken<MatSelectConfig>;

// @public
export const MAT_SELECT_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;

// @public @deprecated
export const MAT_SELECT_SCROLL_STRATEGY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: any[];
    useFactory: typeof MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY;
};

// @public @deprecated
export function MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(_overlay: unknown): () => ScrollStrategy;

// @public
export const MAT_SELECT_TRIGGER: InjectionToken<MatSelectTrigger>;

// @public
export class MatError {
    constructor(...args: unknown[]);
    // (undocumented)
    id: string;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatError, "mat-error, [matError]", never, { "id": { "alias": "id"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatError, never>;
}

// @public
export class MatFormField implements FloatingLabelParent, AfterContentInit, AfterContentChecked, AfterViewInit, OnDestroy {
    constructor(...args: unknown[]);
    _animateAndLockLabel(): void;
    // (undocumented)
    protected readonly _animationsDisabled: boolean;
    get appearance(): MatFormFieldAppearance;
    set appearance(value: MatFormFieldAppearance);
    color: ThemePalette;
    get _control(): MatFormFieldControl_2<any>;
    set _control(value: MatFormFieldControl_2<any>);
    // (undocumented)
    _elementRef: ElementRef<any>;
    // (undocumented)
    _errorChildren: QueryList<MatError>;
    // (undocumented)
    _floatingLabel: MatFormFieldFloatingLabel | undefined;
    get floatLabel(): FloatLabelType;
    set floatLabel(value: FloatLabelType);
    _forceDisplayInfixLabel(): boolean | 0;
    // (undocumented)
    _formFieldControl: MatFormFieldControl_2<any>;
    getConnectedOverlayOrigin(): ElementRef;
    getLabelId: i0.Signal<string | null>;
    _getSubscriptMessageType(): 'error' | 'hint';
    _handleLabelResized(): void;
    // (undocumented)
    _hasFloatingLabel: i0.Signal<boolean>;
    // (undocumented)
    _hasIconPrefix: boolean;
    // (undocumented)
    _hasIconSuffix: boolean;
    // (undocumented)
    _hasOutline(): boolean;
    // (undocumented)
    _hasTextPrefix: boolean;
    // (undocumented)
    _hasTextSuffix: boolean;
    get hideRequiredMarker(): boolean;
    set hideRequiredMarker(value: BooleanInput);
    // (undocumented)
    _hintChildren: QueryList<MatHint>;
    get hintLabel(): string;
    set hintLabel(value: string);
    // (undocumented)
    readonly _hintLabelId: string;
    // (undocumented)
    _iconPrefixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    _iconSuffixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    readonly _labelId: string;
    // (undocumented)
    _lineRipple: MatFormFieldLineRipple | undefined;
    // (undocumented)
    ngAfterContentChecked(): void;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _notchedOutline: MatFormFieldNotchedOutline | undefined;
    // (undocumented)
    _prefixChildren: QueryList<MatPrefix>;
    _refreshOutlineNotchWidth(): void;
    _shouldAlwaysFloat(): boolean;
    _shouldForward(prop: keyof AbstractControlDirective): boolean;
    // (undocumented)
    _shouldLabelFloat(): boolean;
    get subscriptSizing(): SubscriptSizing;
    set subscriptSizing(value: SubscriptSizing);
    // (undocumented)
    _suffixChildren: QueryList<MatSuffix>;
    // (undocumented)
    _textField: ElementRef<HTMLElement>;
    // (undocumented)
    _textPrefixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    _textSuffixContainer: ElementRef<HTMLElement>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatFormField, "mat-form-field", ["matFormField"], { "hideRequiredMarker": { "alias": "hideRequiredMarker"; "required": false; }; "color": { "alias": "color"; "required": false; }; "floatLabel": { "alias": "floatLabel"; "required": false; }; "appearance": { "alias": "appearance"; "required": false; }; "subscriptSizing": { "alias": "subscriptSizing"; "required": false; }; "hintLabel": { "alias": "hintLabel"; "required": false; }; }, {}, ["_labelChild", "_formFieldControl", "_prefixChildren", "_suffixChildren", "_errorChildren", "_hintChildren"], ["mat-label", "[matPrefix], [matIconPrefix]", "[matTextPrefix]", "*", "[matTextSuffix]", "[matSuffix], [matIconSuffix]", "mat-error, [matError]", "mat-hint:not([align='end'])", "mat-hint[align='end']"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatFormField, never>;
}

// @public
export class MatHint {
    align: 'start' | 'end';
    id: string;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatHint, "mat-hint", never, { "align": { "alias": "align"; "required": false; }; "id": { "alias": "id"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatHint, never>;
}

// @public
export class MatLabel {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatLabel, "mat-label", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatLabel, never>;
}

// @public
export class MatOptgroup {
    constructor(...args: unknown[]);
    disabled: boolean;
    _inert: boolean;
    label: string;
    _labelId: string;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatOptgroup, "mat-optgroup", ["matOptgroup"], { "label": { "alias": "label"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; }, {}, never, ["*", "mat-option, ng-container"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatOptgroup, never>;
}

// @public
export class MatOption<T = any> implements FocusableOption, AfterViewChecked, OnDestroy {
    constructor(...args: unknown[]);
    get active(): boolean;
    // (undocumented)
    _changeDetectorRef: ChangeDetectorRef;
    deselect(emitEvent?: boolean): void;
    get disabled(): boolean;
    set disabled(value: boolean);
    get disableRipple(): boolean;
    focus(_origin?: FocusOrigin, options?: FocusOptions): void;
    _getHostElement(): HTMLElement;
    getLabel(): string;
    _getTabIndex(): string;
    // (undocumented)
    group: MatOptgroup | null;
    _handleKeydown(event: KeyboardEvent): void;
    get hideSingleSelectionIndicator(): boolean;
    id: string;
    get multiple(): boolean | null | undefined;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    ngAfterViewChecked(): void;
    // (undocumented)
    ngOnDestroy(): void;
    readonly onSelectionChange: EventEmitter<MatOptionSelectionChange<T>>;
    select(emitEvent?: boolean): void;
    get selected(): boolean;
    _selectViaInteraction(): void;
    setActiveStyles(): void;
    setInactiveStyles(): void;
    readonly _stateChanges: Subject<void>;
    _text: ElementRef<HTMLElement> | undefined;
    value: T;
    get viewValue(): string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatOption<any>, "mat-option", ["matOption"], { "value": { "alias": "value"; "required": false; }; "id": { "alias": "id"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; }, { "onSelectionChange": "onSelectionChange"; }, never, ["mat-icon", "*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatOption<any>, never>;
}

// @public
export class MatPrefix {
    // (undocumented)
    _isText: boolean;
    // (undocumented)
    set _isTextSelector(value: '');
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatPrefix, "[matPrefix], [matIconPrefix], [matTextPrefix]", never, { "_isTextSelector": { "alias": "matTextPrefix"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatPrefix, never>;
}

// @public (undocumented)
export class MatSelect implements AfterContentInit, OnChanges, OnDestroy, OnInit, DoCheck, ControlValueAccessor, MatFormFieldControl<any> {
    constructor(...args: unknown[]);
    // (undocumented)
    protected _animationsDisabled: boolean;
    ariaLabel: string;
    ariaLabelledby: string;
    protected _canOpen(): boolean;
    canSelectNullableOptions: boolean;
    // (undocumented)
    protected _changeDetectorRef: ChangeDetectorRef;
    close(): void;
    readonly _closedStream: Observable<void>;
    get compareWith(): (o1: any, o2: any) => boolean;
    set compareWith(fn: (o1: any, o2: any) => boolean);
    controlType: string;
    customTrigger: MatSelectTrigger;
    // (undocumented)
    protected _defaultOptions: MatSelectConfig | null;
    get describedByIds(): string[];
    protected readonly _destroy: Subject<void>;
    readonly disableAutomaticLabeling = true;
    disabled: boolean;
    disableOptionCentering: boolean;
    get disableRipple(): boolean;
    set disableRipple(value: boolean);
    // (undocumented)
    readonly _elementRef: ElementRef<any>;
    get empty(): boolean;
    get errorState(): boolean;
    set errorState(value: boolean);
    get errorStateMatcher(): ErrorStateMatcher;
    set errorStateMatcher(value: ErrorStateMatcher);
    focus(options?: FocusOptions): void;
    get focused(): boolean;
    _getAriaActiveDescendant(): string | null;
    _getPanelAriaLabelledby(): string | null;
    _getPanelTheme(): string;
    _handleKeydown(event: KeyboardEvent): void;
    protected _handleOverlayKeydown(event: KeyboardEvent): void;
    get hideSingleSelectionIndicator(): boolean;
    set hideSingleSelectionIndicator(value: boolean);
    get id(): string;
    set id(value: string);
    _isRtl(): boolean;
    _keyManager: ActiveDescendantKeyManager<MatOption>;
    get multiple(): boolean;
    set multiple(value: boolean);
    // (undocumented)
    static ngAcceptInputType_canSelectNullableOptions: unknown;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    static ngAcceptInputType_disableOptionCentering: unknown;
    // (undocumented)
    static ngAcceptInputType_disableRipple: unknown;
    // (undocumented)
    static ngAcceptInputType_hideSingleSelectionIndicator: unknown;
    // (undocumented)
    static ngAcceptInputType_multiple: unknown;
    // (undocumented)
    static ngAcceptInputType_required: unknown;
    // (undocumented)
    static ngAcceptInputType_tabIndex: unknown;
    // (undocumented)
    static ngAcceptInputType_typeaheadDebounceInterval: unknown;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngControl: NgControl;
    // (undocumented)
    ngDoCheck(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    _onBlur(): void;
    _onChange: (value: any) => void;
    onContainerClick(): void;
    // (undocumented)
    _onFocus(): void;
    _onTouched: () => void;
    open(): void;
    readonly openedChange: EventEmitter<boolean>;
    readonly _openedStream: Observable<void>;
    optionGroups: QueryList<MatOptgroup>;
    options: QueryList<MatOption>;
    readonly optionSelectionChanges: Observable<MatOptionSelectionChange>;
    protected _overlayDir: CdkConnectedOverlay;
    // (undocumented)
    _overlayPanelClass: string | string[];
    _overlayWidth: string | number;
    panel: ElementRef;
    panelClass: string | string[] | Set<string> | {
        [key: string]: any;
    };
    get panelOpen(): boolean;
    panelWidth: string | number | null;
    // (undocumented)
    protected _parentFormField: MatFormField | null;
    get placeholder(): string;
    set placeholder(value: string);
    _positions: ConnectedPosition[];
    _preferredOverlayOrigin: CdkOverlayOrigin | ElementRef | undefined;
    registerOnChange(fn: (value: any) => void): void;
    registerOnTouched(fn: () => {}): void;
    get required(): boolean;
    set required(value: boolean);
    _scrollOptionIntoView(index: number): void;
    _scrollStrategy: ScrollStrategy;
    get selected(): MatOption | MatOption[];
    readonly selectionChange: EventEmitter<MatSelectChange<any>>;
    _selectionModel: SelectionModel<MatOption>;
    setDescribedByIds(ids: string[]): void;
    setDisabledState(isDisabled: boolean): void;
    get shouldLabelFloat(): boolean;
    sortComparator: (a: MatOption, b: MatOption, options: MatOption[]) => number;
    readonly stateChanges: Subject<void>;
    _syncParentProperties(): void;
    tabIndex: number;
    toggle(): void;
    trigger: ElementRef;
    get triggerValue(): string;
    typeaheadDebounceInterval: number;
    updateErrorState(): void;
    userAriaDescribedBy: string;
    get value(): any;
    set value(newValue: any);
    readonly valueChange: EventEmitter<any>;
    _valueId: string;
    // (undocumented)
    protected _viewportRuler: ViewportRuler;
    writeValue(value: any): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatSelect, "mat-select", ["matSelect"], { "userAriaDescribedBy": { "alias": "aria-describedby"; "required": false; }; "panelClass": { "alias": "panelClass"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "disableRipple": { "alias": "disableRipple"; "required": false; }; "tabIndex": { "alias": "tabIndex"; "required": false; }; "hideSingleSelectionIndicator": { "alias": "hideSingleSelectionIndicator"; "required": false; }; "placeholder": { "alias": "placeholder"; "required": false; }; "required": { "alias": "required"; "required": false; }; "multiple": { "alias": "multiple"; "required": false; }; "disableOptionCentering": { "alias": "disableOptionCentering"; "required": false; }; "compareWith": { "alias": "compareWith"; "required": false; }; "value": { "alias": "value"; "required": false; }; "ariaLabel": { "alias": "aria-label"; "required": false; }; "ariaLabelledby": { "alias": "aria-labelledby"; "required": false; }; "errorStateMatcher": { "alias": "errorStateMatcher"; "required": false; }; "typeaheadDebounceInterval": { "alias": "typeaheadDebounceInterval"; "required": false; }; "sortComparator": { "alias": "sortComparator"; "required": false; }; "id": { "alias": "id"; "required": false; }; "panelWidth": { "alias": "panelWidth"; "required": false; }; "canSelectNullableOptions": { "alias": "canSelectNullableOptions"; "required": false; }; }, { "openedChange": "openedChange"; "_openedStream": "opened"; "_closedStream": "closed"; "selectionChange": "selectionChange"; "valueChange": "valueChange"; }, ["customTrigger", "options", "optionGroups"], ["mat-select-trigger", "*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatSelect, never>;
}

// @public @deprecated
export const matSelectAnimations: {
    readonly transformPanel: any;
};

// @public
export class MatSelectChange<T = any> {
    constructor(
    source: MatSelect,
    value: T);
    source: MatSelect;
    value: T;
}

// @public
export interface MatSelectConfig {
    canSelectNullableOptions?: boolean;
    disableOptionCentering?: boolean;
    hideSingleSelectionIndicator?: boolean;
    overlayPanelClass?: string | string[];
    panelWidth?: string | number | null;
    typeaheadDebounceInterval?: number;
}

// @public (undocumented)
export class MatSelectModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatSelectModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatSelectModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatSelectModule, never, [typeof i2.OverlayModule, typeof MatOptionModule, typeof MatCommonModule, typeof MatSelect, typeof MatSelectTrigger], [typeof i5.CdkScrollableModule, typeof MatFormFieldModule, typeof MatSelect, typeof MatSelectTrigger, typeof MatOptionModule, typeof MatCommonModule]>;
}

// @public
export class MatSelectTrigger {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatSelectTrigger, "mat-select-trigger", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatSelectTrigger, never>;
}

// @public
export class MatSuffix {
    // (undocumented)
    _isText: boolean;
    // (undocumented)
    set _isTextSelector(value: '');
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatSuffix, "[matSuffix], [matIconSuffix], [matTextSuffix]", never, { "_isTextSelector": { "alias": "matTextSuffix"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatSuffix, never>;
}

// (No @packageDocumentation comment for this package)

```
