## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbstractControl } from '@angular/forms';
import { AfterContentInit } from '@angular/core';
import { AfterViewChecked } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { AnimationEvent as AnimationEvent_2 } from '@angular/animations';
import { AnimationTriggerMetadata } from '@angular/animations';
import { ChangeDetectorRef } from '@angular/core';
import { ComponentType } from '@angular/cdk/portal';
import { ControlContainer } from '@angular/forms';
import { ControlValueAccessor } from '@angular/forms';
import { DateAdapter } from '@angular/material/core';
import { Directionality } from '@angular/cdk/bidi';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import { ErrorStateMatcher } from '@angular/material/core';
import { EventEmitter } from '@angular/core';
import { FactoryProvider } from '@angular/core';
import { FocusOrigin } from '@angular/cdk/a11y';
import { FormGroupDirective } from '@angular/forms';
import * as i0 from '@angular/core';
import * as i1 from '@angular/common';
import * as i2 from '@angular/material/button';
import * as i20 from '@angular/cdk/scrolling';
import * as i3 from '@angular/cdk/overlay';
import * as i4 from '@angular/cdk/a11y';
import * as i5 from '@angular/cdk/portal';
import * as i6 from '@angular/material/core';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { MatButton } from '@angular/material/button';
import { MatDateFormats } from '@angular/material/core';
import { MatFormFieldControl } from '@angular/material/form-field';
import { NgControl } from '@angular/forms';
import { NgForm } from '@angular/forms';
import { NgZone } from '@angular/core';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Overlay } from '@angular/cdk/overlay';
import { Portal } from '@angular/cdk/portal';
import { ScrollStrategy } from '@angular/cdk/overlay';
import { Signal } from '@angular/core';
import { SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { TemplatePortal } from '@angular/cdk/portal';
import { TemplateRef } from '@angular/core';
import { ThemePalette } from '@angular/material/core';
import { ValidationErrors } from '@angular/forms';
import { Validator } from '@angular/forms';
import { ValidatorFn } from '@angular/forms';
import { ViewContainerRef } from '@angular/core';
import { WritableSignal } from '@angular/core';

// @public
export type DateFilterFn<D> = (date: D | null) => boolean;

// @public
export type DatepickerDropdownPositionX = 'start' | 'end';

// @public
export type DatepickerDropdownPositionY = 'above' | 'below';

// @public
export class DateRange<D> {
    constructor(
    start: D | null,
    end: D | null);
    readonly end: D | null;
    readonly start: D | null;
}

// @public
export interface DateSelectionModelChange<S> {
    oldValue?: S;
    selection: S;
    source: unknown;
}

// @public
export class DefaultMatCalendarRangeStrategy<D> implements MatDateRangeSelectionStrategy<D> {
    constructor(_dateAdapter: DateAdapter<D>);
    // (undocumented)
    createDrag(dragOrigin: D, originalRange: DateRange<D>, newDate: D): DateRange<D> | null;
    // (undocumented)
    createPreview(activeDate: D | null, currentRange: DateRange<D>): DateRange<D>;
    // (undocumented)
    selectionFinished(date: D, currentRange: DateRange<D>): DateRange<D>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<DefaultMatCalendarRangeStrategy<any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<DefaultMatCalendarRangeStrategy<any>>;
}

// @public
export type ExtractDateTypeFromSelection<T> = T extends DateRange<infer D> ? D : NonNullable<T>;

// @public
export const MAT_DATE_RANGE_SELECTION_STRATEGY: InjectionToken<MatDateRangeSelectionStrategy<any>>;

// @public
export const MAT_DATEPICKER_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;

// @public
export function MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy;

// @public
export const MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    deps: (typeof Overlay)[];
    useFactory: typeof MAT_DATEPICKER_SCROLL_STRATEGY_FACTORY;
};

// @public
export const MAT_DATEPICKER_VALIDATORS: any;

// @public
export const MAT_DATEPICKER_VALUE_ACCESSOR: any;

// @public
export function MAT_RANGE_DATE_SELECTION_MODEL_FACTORY(parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>): MatSingleDateSelectionModel<unknown>;

// @public
export const MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider;

// @public
export function MAT_SINGLE_DATE_SELECTION_MODEL_FACTORY(parent: MatSingleDateSelectionModel<unknown>, adapter: DateAdapter<unknown>): MatSingleDateSelectionModel<unknown>;

// @public
export const MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER: FactoryProvider;

// @public
export class MatCalendar<D> implements AfterContentInit, AfterViewChecked, OnDestroy, OnChanges {
    constructor(_intl: MatDatepickerIntl, _dateAdapter: DateAdapter<D>, _dateFormats: MatDateFormats, _changeDetectorRef: ChangeDetectorRef);
    get activeDate(): D;
    set activeDate(value: D);
    protected _activeDrag: MatCalendarUserEvent<D> | null;
    _calendarHeaderPortal: Portal<any>;
    comparisonEnd: D | null;
    comparisonStart: D | null;
    get currentView(): MatCalendarView;
    set currentView(value: MatCalendarView);
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _dateSelected(event: MatCalendarUserEvent<D | null>): void;
    _dragEnded(event: MatCalendarUserEvent<DateRange<D> | null>): void;
    _dragStarted(event: MatCalendarUserEvent<D>): void;
    endDateAccessibleName: string | null;
    focusActiveCell(): void;
    _goToDateInView(date: D, view: 'month' | 'year' | 'multi-year'): void;
    headerComponent: ComponentType<any>;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    readonly monthSelected: EventEmitter<D>;
    _monthSelectedInYearView(normalizedMonth: D): void;
    monthView: MatMonthView<D>;
    multiYearView: MatMultiYearView<D>;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngAfterViewChecked(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D | null>;
    get startAt(): D | null;
    set startAt(value: D | null);
    startDateAccessibleName: string | null;
    startView: MatCalendarView;
    readonly stateChanges: Subject<void>;
    updateTodaysDate(): void;
    readonly _userDragDrop: EventEmitter<MatCalendarUserEvent<DateRange<D>>>;
    readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>>;
    readonly viewChanged: EventEmitter<MatCalendarView>;
    readonly yearSelected: EventEmitter<D>;
    _yearSelectedInMultiYearView(normalizedYear: D): void;
    yearView: MatYearView<D>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendar<any>, "mat-calendar", ["matCalendar"], { "headerComponent": { "alias": "headerComponent"; "required": false; }; "startAt": { "alias": "startAt"; "required": false; }; "startView": { "alias": "startView"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "minDate": { "alias": "minDate"; "required": false; }; "maxDate": { "alias": "maxDate"; "required": false; }; "dateFilter": { "alias": "dateFilter"; "required": false; }; "dateClass": { "alias": "dateClass"; "required": false; }; "comparisonStart": { "alias": "comparisonStart"; "required": false; }; "comparisonEnd": { "alias": "comparisonEnd"; "required": false; }; "startDateAccessibleName": { "alias": "startDateAccessibleName"; "required": false; }; "endDateAccessibleName": { "alias": "endDateAccessibleName"; "required": false; }; }, { "selectedChange": "selectedChange"; "yearSelected": "yearSelected"; "monthSelected": "monthSelected"; "viewChanged": "viewChanged"; "_userSelection": "_userSelection"; "_userDragDrop": "_userDragDrop"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendar<any>, [null, { optional: true; }, { optional: true; }, null]>;
}

// @public
export class MatCalendarBody<D = any> implements OnChanges, OnDestroy, AfterViewChecked {
    constructor(_elementRef: ElementRef<HTMLElement>, _ngZone: NgZone);
    activeCell: number;
    // (undocumented)
    readonly activeDateChange: EventEmitter<MatCalendarUserEvent<number>>;
    cellAspectRatio: number;
    _cellClicked(cell: MatCalendarCell, event: MouseEvent): void;
    _cellPadding: string;
    _cellWidth: string;
    comparisonEnd: number | null;
    comparisonStart: number | null;
    readonly dragEnded: EventEmitter<MatCalendarUserEvent<D | null>>;
    readonly dragStarted: EventEmitter<MatCalendarUserEvent<D>>;
    // (undocumented)
    _emitActiveDateChange(cell: MatCalendarCell, event: FocusEvent): void;
    endDateAccessibleName: string | null;
    // (undocumented)
    _endDateLabelId: string;
    endValue: number;
    _firstRowOffset: number;
    _focusActiveCell(movePreview?: boolean): void;
    _getDescribedby(value: number): string | null;
    _isActiveCell(rowIndex: number, colIndex: number): boolean;
    _isComparisonBridgeEnd(value: number, rowIndex: number, colIndex: number): boolean;
    _isComparisonBridgeStart(value: number, rowIndex: number, colIndex: number): boolean;
    _isComparisonEnd(value: number): boolean;
    _isComparisonIdentical(value: number): boolean;
    _isComparisonStart(value: number): boolean;
    _isInComparisonRange(value: number): boolean;
    _isInPreview(value: number): boolean;
    _isInRange(value: number): boolean;
    _isPreviewEnd(value: number): boolean;
    _isPreviewStart(value: number): boolean;
    isRange: boolean;
    _isRangeEnd(value: number): boolean;
    _isRangeStart(value: number): boolean;
    _isSelected(value: number): boolean;
    label: string;
    labelMinRequiredCells: number;
    // (undocumented)
    ngAfterViewChecked(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    numCols: number;
    readonly previewChange: EventEmitter<MatCalendarUserEvent<MatCalendarCell<any> | null>>;
    previewEnd: number | null;
    previewStart: number | null;
    rows: MatCalendarCell[][];
    _scheduleFocusActiveCellAfterViewChecked(): void;
    readonly selectedValueChange: EventEmitter<MatCalendarUserEvent<number>>;
    startDateAccessibleName: string | null;
    // (undocumented)
    _startDateLabelId: string;
    startValue: number;
    todayValue: number;
    _trackRow: (row: MatCalendarCell[]) => MatCalendarCell<any>[];
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendarBody<any>, "[mat-calendar-body]", ["matCalendarBody"], { "label": { "alias": "label"; "required": false; }; "rows": { "alias": "rows"; "required": false; }; "todayValue": { "alias": "todayValue"; "required": false; }; "startValue": { "alias": "startValue"; "required": false; }; "endValue": { "alias": "endValue"; "required": false; }; "labelMinRequiredCells": { "alias": "labelMinRequiredCells"; "required": false; }; "numCols": { "alias": "numCols"; "required": false; }; "activeCell": { "alias": "activeCell"; "required": false; }; "isRange": { "alias": "isRange"; "required": false; }; "cellAspectRatio": { "alias": "cellAspectRatio"; "required": false; }; "comparisonStart": { "alias": "comparisonStart"; "required": false; }; "comparisonEnd": { "alias": "comparisonEnd"; "required": false; }; "previewStart": { "alias": "previewStart"; "required": false; }; "previewEnd": { "alias": "previewEnd"; "required": false; }; "startDateAccessibleName": { "alias": "startDateAccessibleName"; "required": false; }; "endDateAccessibleName": { "alias": "endDateAccessibleName"; "required": false; }; }, { "selectedValueChange": "selectedValueChange"; "previewChange": "previewChange"; "activeDateChange": "activeDateChange"; "dragStarted": "dragStarted"; "dragEnded": "dragEnded"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendarBody<any>, never>;
}

// @public
export class MatCalendarCell<D = any> {
    constructor(value: number, displayValue: string, ariaLabel: string, enabled: boolean, cssClasses?: MatCalendarCellCssClasses, compareValue?: number, rawValue?: D | undefined);
    // (undocumented)
    ariaLabel: string;
    // (undocumented)
    compareValue: number;
    // (undocumented)
    cssClasses: MatCalendarCellCssClasses;
    // (undocumented)
    displayValue: string;
    // (undocumented)
    enabled: boolean;
    // (undocumented)
    readonly id: number;
    // (undocumented)
    rawValue?: D | undefined;
    // (undocumented)
    value: number;
}

// @public
export type MatCalendarCellClassFunction<D> = (date: D, view: 'month' | 'year' | 'multi-year') => MatCalendarCellCssClasses;

// @public
export type MatCalendarCellCssClasses = string | string[] | Set<string> | {
    [key: string]: any;
};

// @public
export class MatCalendarHeader<D> {
    constructor(_intl: MatDatepickerIntl, calendar: MatCalendar<D>, _dateAdapter: DateAdapter<D>, _dateFormats: MatDateFormats, changeDetectorRef: ChangeDetectorRef);
    // (undocumented)
    calendar: MatCalendar<D>;
    currentPeriodClicked(): void;
    get nextButtonLabel(): string;
    nextClicked(): void;
    nextEnabled(): boolean;
    get periodButtonDescription(): string;
    get periodButtonLabel(): string;
    // (undocumented)
    _periodButtonLabelId: string;
    get periodButtonText(): string;
    get prevButtonLabel(): string;
    previousClicked(): void;
    previousEnabled(): boolean;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatCalendarHeader<any>, "mat-calendar-header", ["matCalendarHeader"], {}, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatCalendarHeader<any>, [null, null, { optional: true; }, { optional: true; }, null]>;
}

// @public
export interface MatCalendarUserEvent<D> {
    // (undocumented)
    event: Event;
    // (undocumented)
    value: D;
}

// @public
export type MatCalendarView = 'month' | 'year' | 'multi-year';

// @public
export class MatDatepicker<D> extends MatDatepickerBase<MatDatepickerControl<D>, D | null, D> {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepicker<any>, "mat-datepicker", ["matDatepicker"], {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepicker<any>, never>;
}

// @public
export class MatDatepickerActions implements AfterViewInit, OnDestroy {
    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>, _viewContainerRef: ViewContainerRef);
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _template: TemplateRef<unknown>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerActions, "mat-datepicker-actions, mat-date-range-picker-actions", never, {}, {}, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerActions, never>;
}

// @public
export const matDatepickerAnimations: {
    readonly transformPanel: AnimationTriggerMetadata;
    readonly fadeInCalendar: AnimationTriggerMetadata;
};

// @public
export class MatDatepickerApply {
    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>);
    // (undocumented)
    _applySelection(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerApply, "[matDatepickerApply], [matDateRangePickerApply]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerApply, never>;
}

// @public
export class MatDatepickerCancel {
    constructor(_datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>);
    // (undocumented)
    _datepicker: MatDatepickerBase<MatDatepickerControl<any>, unknown>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerCancel, "[matDatepickerCancel], [matDateRangePickerCancel]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerCancel, never>;
}

// @public
export class MatDatepickerContent<S, D = ExtractDateTypeFromSelection<S>> implements OnInit, AfterViewInit, OnDestroy {
    constructor(_elementRef: ElementRef, _changeDetectorRef: ChangeDetectorRef, _globalModel: MatDateSelectionModel<S, D>, _dateAdapter: DateAdapter<D>, _rangeSelectionStrategy: MatDateRangeSelectionStrategy<D>, intl: MatDatepickerIntl);
    _actionsPortal: TemplatePortal | null;
    readonly _animationDone: Subject<void>;
    _animationState: 'enter-dropdown' | 'enter-dialog' | 'void';
    _applyPendingSelection(): void;
    _assignActions(portal: TemplatePortal<any> | null, forceRerender: boolean): void;
    _calendar: MatCalendar<D>;
    _closeButtonFocused: boolean;
    _closeButtonText: string;
    color: ThemePalette;
    comparisonEnd: D | null;
    comparisonStart: D | null;
    datepicker: MatDatepickerBase<any, S, D>;
    _dialogLabelId: string | null;
    // (undocumented)
    protected _elementRef: ElementRef;
    endDateAccessibleName: string | null;
    // (undocumented)
    _getSelected(): D | DateRange<D> | null;
    // (undocumented)
    _handleAnimationEvent(event: AnimationEvent_2): void;
    // (undocumented)
    _handleUserDragDrop(event: MatCalendarUserEvent<DateRange<D>>): void;
    // (undocumented)
    _handleUserSelection(event: MatCalendarUserEvent<D | null>): void;
    _isAbove: boolean;
    _isAnimating: boolean;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    startDateAccessibleName: string | null;
    // (undocumented)
    _startExitAnimation(): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerContent<any, any>, "mat-datepicker-content", ["matDatepickerContent"], { "color": { "alias": "color"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerContent<any, any>, [null, null, null, null, { optional: true; }, null]>;
}

// @public
export interface MatDatepickerControl<D> {
    // (undocumented)
    dateFilter: DateFilterFn<D>;
    // (undocumented)
    disabled: boolean;
    // (undocumented)
    getConnectedOverlayOrigin(): ElementRef;
    // (undocumented)
    getOverlayLabelId(): string | null;
    // (undocumented)
    getStartValue(): D | null;
    // (undocumented)
    getThemePalette(): ThemePalette;
    // (undocumented)
    max: D | null;
    // (undocumented)
    min: D | null;
    // (undocumented)
    stateChanges: Observable<void>;
}

// @public
export class MatDatepickerInput<D> extends MatDatepickerInputBase<D | null, D> implements MatDatepickerControl<D | null>, OnDestroy {
    constructor(elementRef: ElementRef<HTMLInputElement>, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats, _formField?: _MatFormFieldPartial | undefined);
    protected _ariaOwns: WritableSignal<string | null>;
    // (undocumented)
    protected _assignValueToModel(value: D | null): void;
    get dateFilter(): DateFilterFn<D | null>;
    set dateFilter(value: DateFilterFn<D | null>);
    // (undocumented)
    _datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>;
    getConnectedOverlayOrigin(): ElementRef;
    protected _getDateFilter(): DateFilterFn<D | null>;
    _getMaxDate(): D | null;
    _getMinDate(): D | null;
    getOverlayLabelId(): string | null;
    getStartValue(): D | null;
    getThemePalette(): ThemePalette;
    // (undocumented)
    protected _getValueFromModel(modelValue: D | null): D | null;
    set matDatepicker(datepicker: MatDatepickerPanel<MatDatepickerControl<D>, D | null, D>);
    get max(): D | null;
    set max(value: D | null);
    get min(): D | null;
    set min(value: D | null);
    // (undocumented)
    ngOnDestroy(): void;
    protected _openPopup(): void;
    // (undocumented)
    protected _shouldHandleChangeEvent(event: DateSelectionModelChange<D>): boolean;
    protected _validator: ValidatorFn | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerInput<any>, "input[matDatepicker]", ["matDatepickerInput"], { "matDatepicker": { "alias": "matDatepicker"; "required": false; }; "min": { "alias": "min"; "required": false; }; "max": { "alias": "max"; "required": false; }; "dateFilter": { "alias": "matDatepickerFilter"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerInput<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatDatepickerInputEvent<D, S = unknown> {
    constructor(
    target: MatDatepickerInputBase<S, D>,
    targetElement: HTMLElement);
    target: MatDatepickerInputBase<S, D>;
    targetElement: HTMLElement;
    value: D | null;
}

// @public
export class MatDatepickerIntl {
    calendarLabel: string;
    readonly changes: Subject<void>;
    closeCalendarLabel: string;
    // @deprecated
    endDateLabel: string;
    formatYearRange(start: string, end: string): string;
    formatYearRangeLabel(start: string, end: string): string;
    nextMonthLabel: string;
    nextMultiYearLabel: string;
    nextYearLabel: string;
    openCalendarLabel: string;
    prevMonthLabel: string;
    prevMultiYearLabel: string;
    prevYearLabel: string;
    // @deprecated
    startDateLabel: string;
    switchToMonthViewLabel: string;
    switchToMultiYearViewLabel: string;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerIntl, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatDatepickerIntl>;
}

// @public (undocumented)
export class MatDatepickerModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<MatDatepickerModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<MatDatepickerModule, never, [typeof i1.CommonModule, typeof i2.MatButtonModule, typeof i3.OverlayModule, typeof i4.A11yModule, typeof i5.PortalModule, typeof i6.MatCommonModule, typeof i7.MatCalendar, typeof i8.MatCalendarBody, typeof i9.MatDatepicker, typeof i10.MatDatepickerContent, typeof i11.MatDatepickerInput, typeof i12.MatDatepickerToggle, typeof i12.MatDatepickerToggleIcon, typeof i13.MatMonthView, typeof i14.MatYearView, typeof i15.MatMultiYearView, typeof i7.MatCalendarHeader, typeof i16.MatDateRangeInput, typeof i17.MatStartDate, typeof i17.MatEndDate, typeof i18.MatDateRangePicker, typeof i19.MatDatepickerActions, typeof i19.MatDatepickerCancel, typeof i19.MatDatepickerApply], [typeof i20.CdkScrollableModule, typeof i7.MatCalendar, typeof i8.MatCalendarBody, typeof i9.MatDatepicker, typeof i10.MatDatepickerContent, typeof i11.MatDatepickerInput, typeof i12.MatDatepickerToggle, typeof i12.MatDatepickerToggleIcon, typeof i13.MatMonthView, typeof i14.MatYearView, typeof i15.MatMultiYearView, typeof i7.MatCalendarHeader, typeof i16.MatDateRangeInput, typeof i17.MatStartDate, typeof i17.MatEndDate, typeof i18.MatDateRangePicker, typeof i19.MatDatepickerActions, typeof i19.MatDatepickerCancel, typeof i19.MatDatepickerApply]>;
}

// @public
export interface MatDatepickerPanel<C extends MatDatepickerControl<D>, S, D = ExtractDateTypeFromSelection<S>> {
    closedStream: EventEmitter<void>;
    color: ThemePalette;
    datepickerInput: C;
    disabled: boolean;
    id: string;
    open(): void;
    opened: boolean;
    openedStream: EventEmitter<void>;
    registerInput(input: C): MatDateSelectionModel<S, D>;
    stateChanges: Subject<void>;
}

// @public (undocumented)
export class MatDatepickerToggle<D> implements AfterContentInit, OnChanges, OnDestroy {
    constructor(_intl: MatDatepickerIntl, _changeDetectorRef: ChangeDetectorRef, defaultTabIndex: string);
    ariaLabel: string;
    _button: MatButton;
    _customIcon: MatDatepickerToggleIcon;
    datepicker: MatDatepickerPanel<MatDatepickerControl<any>, D>;
    get disabled(): boolean;
    set disabled(value: boolean);
    disableRipple: boolean;
    // (undocumented)
    _intl: MatDatepickerIntl;
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _open(event: Event): void;
    tabIndex: number | null;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDatepickerToggle<any>, "mat-datepicker-toggle", ["matDatepickerToggle"], { "datepicker": { "alias": "for"; "required": false; }; "tabIndex": { "alias": "tabIndex"; "required": false; }; "ariaLabel": { "alias": "aria-label"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "disableRipple": { "alias": "disableRipple"; "required": false; }; }, {}, ["_customIcon"], ["[matDatepickerToggleIcon]"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerToggle<any>, [null, null, { attribute: "tabindex"; }]>;
}

// @public
export class MatDatepickerToggleIcon {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatDatepickerToggleIcon, "[matDatepickerToggleIcon]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDatepickerToggleIcon, never>;
}

// @public (undocumented)
export class MatDateRangeInput<D> implements MatFormFieldControl<DateRange<D>>, MatDatepickerControl<D>, MatDateRangeInputParent<D>, MatDateRangePickerInput<D>, AfterContentInit, OnChanges, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _elementRef: ElementRef<HTMLElement>, control: ControlContainer, _dateAdapter: DateAdapter<D>, _formField?: _MatFormFieldPartial | undefined);
    _ariaDescribedBy: string | null;
    _ariaOwns: WritableSignal<string | null>;
    comparisonEnd: D | null;
    comparisonStart: D | null;
    controlType: string;
    get dateFilter(): DateFilterFn<D>;
    set dateFilter(value: DateFilterFn<D>);
    readonly disableAutomaticLabeling = true;
    get disabled(): boolean;
    set disabled(value: boolean);
    get empty(): boolean;
    // (undocumented)
    _endInput: MatEndDate<D>;
    get errorState(): boolean;
    focused: boolean;
    _getAriaLabelledby(): string | null;
    getConnectedOverlayOrigin(): ElementRef;
    // (undocumented)
    _getEndDateAccessibleName(): string;
    _getInputMirrorValue(part: 'start' | 'end'): string;
    getOverlayLabelId(): string | null;
    // (undocumented)
    _getStartDateAccessibleName(): string;
    getStartValue(): D | null;
    getThemePalette(): ThemePalette;
    // (undocumented)
    _groupDisabled: boolean;
    _handleChildValueChange(): void;
    id: string;
    get max(): D | null;
    set max(value: D | null);
    get min(): D | null;
    set min(value: D | null);
    // (undocumented)
    static ngAcceptInputType_disabled: unknown;
    // (undocumented)
    static ngAcceptInputType_required: unknown;
    // (undocumented)
    ngAfterContentInit(): void;
    ngControl: NgControl | null;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    onContainerClick(): void;
    _openDatepicker(): void;
    get placeholder(): string;
    get rangePicker(): MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>;
    set rangePicker(rangePicker: MatDatepickerPanel<MatDatepickerControl<D>, DateRange<D>, D>);
    get required(): boolean;
    set required(value: boolean);
    separator: string;
    setDescribedByIds(ids: string[]): void;
    _shouldHidePlaceholders(): boolean;
    _shouldHideSeparator(): boolean | "" | null;
    get shouldLabelFloat(): boolean;
    // (undocumented)
    _startInput: MatStartDate<D>;
    readonly stateChanges: Subject<void>;
    _updateFocus(origin: FocusOrigin): void;
    get value(): DateRange<D> | null;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDateRangeInput<any>, "mat-date-range-input", ["matDateRangeInput"], { "rangePicker": { "alias": "rangePicker"; "required": false; }; "required": { "alias": "required"; "required": false; }; "dateFilter": { "alias": "dateFilter"; "required": false; }; "min": { "alias": "min"; "required": false; }; "max": { "alias": "max"; "required": false; }; "disabled": { "alias": "disabled"; "required": false; }; "separator": { "alias": "separator"; "required": false; }; "comparisonStart": { "alias": "comparisonStart"; "required": false; }; "comparisonEnd": { "alias": "comparisonEnd"; "required": false; }; }, {}, ["_startInput", "_endInput"], ["input[matStartDate]", "input[matEndDate]"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateRangeInput<any>, [null, null, { optional: true; self: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatDateRangePicker<D> extends MatDatepickerBase<MatDateRangePickerInput<D>, DateRange<D>, D> {
    // (undocumented)
    protected _forwardContentValues(instance: MatDatepickerContent<DateRange<D>, D>): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatDateRangePicker<any>, "mat-date-range-picker", ["matDateRangePicker"], {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateRangePicker<any>, never>;
}

// @public
export interface MatDateRangeSelectionStrategy<D> {
    createDrag?(dragOrigin: D, originalRange: DateRange<D>, newDate: D, event: Event): DateRange<D> | null;
    createPreview(activeDate: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;
    selectionFinished(date: D | null, currentRange: DateRange<D>, event: Event): DateRange<D>;
}

// @public
export abstract class MatDateSelectionModel<S, D = ExtractDateTypeFromSelection<S>> implements OnDestroy {
    protected constructor(
    selection: S, _adapter: DateAdapter<D>);
    // (undocumented)
    protected _adapter: DateAdapter<D>;
    abstract add(date: D | null): void;
    abstract clone(): MatDateSelectionModel<S, D>;
    abstract isComplete(): boolean;
    abstract isValid(): boolean;
    // (undocumented)
    protected _isValidDateInstance(date: D): boolean;
    // (undocumented)
    ngOnDestroy(): void;
    readonly selection: S;
    selectionChanged: Observable<DateSelectionModelChange<S>>;
    updateSelection(value: S, source: unknown): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatDateSelectionModel<any, any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatDateSelectionModel<any, any>>;
}

// @public
export class MatEndDate<D> extends MatDateRangeInputPartBase<D> {
    constructor(rangeInput: MatDateRangeInputParent<D>, elementRef: ElementRef<HTMLInputElement>, defaultErrorStateMatcher: ErrorStateMatcher, injector: Injector, parentForm: NgForm, parentFormGroup: FormGroupDirective, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats);
    // (undocumented)
    protected _assignValueToModel(value: D | null): void;
    // (undocumented)
    protected _getValueFromModel(modelValue: DateRange<D>): D | null;
    // (undocumented)
    _onKeydown(event: KeyboardEvent): void;
    // (undocumented)
    protected _shouldHandleChangeEvent(change: DateSelectionModelChange<DateRange<D>>): boolean;
    // (undocumented)
    protected _validator: ValidatorFn | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatEndDate<any>, "input[matEndDate]", never, {}, { "dateChange": "dateChange"; "dateInput": "dateInput"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatEndDate<any>, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatMonthView<D> implements AfterContentInit, OnChanges, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _dateFormats: MatDateFormats, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined, _rangeStrategy?: MatDateRangeSelectionStrategy<D> | undefined);
    get activeDate(): D;
    set activeDate(value: D);
    readonly activeDateChange: EventEmitter<D>;
    activeDrag: MatCalendarUserEvent<D> | null;
    // (undocumented)
    readonly _changeDetectorRef: ChangeDetectorRef;
    comparisonEnd: D | null;
    _comparisonRangeEnd: number | null;
    _comparisonRangeStart: number | null;
    comparisonStart: D | null;
    // (undocumented)
    _dateAdapter: DateAdapter<D>;
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _dateSelected(event: MatCalendarUserEvent<number>): void;
    readonly dragEnded: EventEmitter<MatCalendarUserEvent<DateRange<D> | null>>;
    protected _dragEnded(event: MatCalendarUserEvent<D | null>): void;
    readonly dragStarted: EventEmitter<MatCalendarUserEvent<D>>;
    endDateAccessibleName: string | null;
    _firstWeekOffset: number;
    _focusActiveCell(movePreview?: boolean): void;
    _focusActiveCellAfterViewChecked(): void;
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    _handleCalendarBodyKeyup(event: KeyboardEvent): void;
    _init(): void;
    _isRange: boolean;
    _matCalendarBody: MatCalendarBody;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    _monthLabel: string;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    ngOnDestroy(): void;
    _previewChanged({ event, value: cell }: MatCalendarUserEvent<MatCalendarCell<D> | null>): void;
    _previewEnd: number | null;
    _previewStart: number | null;
    _rangeEnd: number | null;
    _rangeStart: number | null;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D | null>;
    startDateAccessibleName: string | null;
    _todayDate: number | null;
    _updateActiveDate(event: MatCalendarUserEvent<number>): void;
    readonly _userSelection: EventEmitter<MatCalendarUserEvent<D | null>>;
    _weekdays: {
        long: string;
        narrow: string;
        id: number;
    }[];
    _weeks: MatCalendarCell[][];
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatMonthView<any>, "mat-month-view", ["matMonthView"], { "activeDate": { "alias": "activeDate"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "minDate": { "alias": "minDate"; "required": false; }; "maxDate": { "alias": "maxDate"; "required": false; }; "dateFilter": { "alias": "dateFilter"; "required": false; }; "dateClass": { "alias": "dateClass"; "required": false; }; "comparisonStart": { "alias": "comparisonStart"; "required": false; }; "comparisonEnd": { "alias": "comparisonEnd"; "required": false; }; "startDateAccessibleName": { "alias": "startDateAccessibleName"; "required": false; }; "endDateAccessibleName": { "alias": "endDateAccessibleName"; "required": false; }; "activeDrag": { "alias": "activeDrag"; "required": false; }; }, { "selectedChange": "selectedChange"; "_userSelection": "_userSelection"; "dragStarted": "dragStarted"; "dragEnded": "dragEnded"; "activeDateChange": "activeDateChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMonthView<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatMultiYearView<D> implements AfterContentInit, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined);
    get activeDate(): D;
    set activeDate(value: D);
    readonly activeDateChange: EventEmitter<D>;
    // (undocumented)
    _dateAdapter: DateAdapter<D>;
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _focusActiveCell(): void;
    _focusActiveCellAfterViewChecked(): void;
    // (undocumented)
    _getActiveCell(): number;
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    _handleCalendarBodyKeyup(event: KeyboardEvent): void;
    _init(): void;
    _matCalendarBody: MatCalendarBody;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D>;
    _selectedYear: number | null;
    _todayYear: number;
    _updateActiveDate(event: MatCalendarUserEvent<number>): void;
    _years: MatCalendarCell[][];
    readonly yearSelected: EventEmitter<D>;
    _yearSelected(event: MatCalendarUserEvent<number>): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatMultiYearView<any>, "mat-multi-year-view", ["matMultiYearView"], { "activeDate": { "alias": "activeDate"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "minDate": { "alias": "minDate"; "required": false; }; "maxDate": { "alias": "maxDate"; "required": false; }; "dateFilter": { "alias": "dateFilter"; "required": false; }; "dateClass": { "alias": "dateClass"; "required": false; }; }, { "selectedChange": "selectedChange"; "yearSelected": "yearSelected"; "activeDateChange": "activeDateChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatMultiYearView<any>, [null, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatRangeDateSelectionModel<D> extends MatDateSelectionModel<DateRange<D>, D> {
    constructor(adapter: DateAdapter<D>);
    add(date: D | null): void;
    clone(): MatRangeDateSelectionModel<D>;
    isComplete(): boolean;
    isValid(): boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatRangeDateSelectionModel<any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatRangeDateSelectionModel<any>>;
}

// @public
export class MatSingleDateSelectionModel<D> extends MatDateSelectionModel<D | null, D> {
    constructor(adapter: DateAdapter<D>);
    add(date: D | null): void;
    clone(): MatSingleDateSelectionModel<D>;
    isComplete(): boolean;
    isValid(): boolean;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatSingleDateSelectionModel<any>, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<MatSingleDateSelectionModel<any>>;
}

// @public
export class MatStartDate<D> extends MatDateRangeInputPartBase<D> {
    constructor(rangeInput: MatDateRangeInputParent<D>, elementRef: ElementRef<HTMLInputElement>, defaultErrorStateMatcher: ErrorStateMatcher, injector: Injector, parentForm: NgForm, parentFormGroup: FormGroupDirective, dateAdapter: DateAdapter<D>, dateFormats: MatDateFormats);
    // (undocumented)
    protected _assignValueToModel(value: D | null): void;
    // (undocumented)
    protected _formatValue(value: D | null): void;
    // (undocumented)
    protected _getValueFromModel(modelValue: DateRange<D>): D | null;
    // (undocumented)
    _onKeydown(event: KeyboardEvent): void;
    // (undocumented)
    protected _shouldHandleChangeEvent(change: DateSelectionModelChange<DateRange<D>>): boolean;
    // (undocumented)
    protected _validator: ValidatorFn | null;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<MatStartDate<any>, "input[matStartDate]", never, {}, { "dateChange": "dateChange"; "dateInput": "dateInput"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatStartDate<any>, [null, null, null, null, { optional: true; }, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public
export class MatYearView<D> implements AfterContentInit, OnDestroy {
    constructor(_changeDetectorRef: ChangeDetectorRef, _dateFormats: MatDateFormats, _dateAdapter: DateAdapter<D>, _dir?: Directionality | undefined);
    get activeDate(): D;
    set activeDate(value: D);
    readonly activeDateChange: EventEmitter<D>;
    // (undocumented)
    readonly _changeDetectorRef: ChangeDetectorRef;
    // (undocumented)
    _dateAdapter: DateAdapter<D>;
    dateClass: MatCalendarCellClassFunction<D>;
    dateFilter: (date: D) => boolean;
    _focusActiveCell(): void;
    _focusActiveCellAfterViewChecked(): void;
    _handleCalendarBodyKeydown(event: KeyboardEvent): void;
    _handleCalendarBodyKeyup(event: KeyboardEvent): void;
    _init(): void;
    _matCalendarBody: MatCalendarBody;
    get maxDate(): D | null;
    set maxDate(value: D | null);
    get minDate(): D | null;
    set minDate(value: D | null);
    _months: MatCalendarCell[][];
    readonly monthSelected: EventEmitter<D>;
    _monthSelected(event: MatCalendarUserEvent<number>): void;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    get selected(): DateRange<D> | D | null;
    set selected(value: DateRange<D> | D | null);
    readonly selectedChange: EventEmitter<D>;
    _selectedMonth: number | null;
    _todayMonth: number | null;
    _updateActiveDate(event: MatCalendarUserEvent<number>): void;
    _yearLabel: string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<MatYearView<any>, "mat-year-view", ["matYearView"], { "activeDate": { "alias": "activeDate"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "minDate": { "alias": "minDate"; "required": false; }; "maxDate": { "alias": "maxDate"; "required": false; }; "dateFilter": { "alias": "dateFilter"; "required": false; }; "dateClass": { "alias": "dateClass"; "required": false; }; }, { "selectedChange": "selectedChange"; "monthSelected": "monthSelected"; "activeDateChange": "activeDateChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<MatYearView<any>, [null, { optional: true; }, { optional: true; }, { optional: true; }]>;
}

// @public (undocumented)
export const yearsPerPage = 24;

// @public (undocumented)
export const yearsPerRow = 4;

// (No @packageDocumentation comment for this package)

```
