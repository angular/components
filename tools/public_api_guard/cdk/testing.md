## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export type AsyncFactoryFn<T> = () => Promise<T>;

// @public
export type AsyncOptionPredicate<T, O> = (item: T, option: O) => Promise<boolean>;

// @public
export type AsyncPredicate<T> = (item: T) => Promise<boolean>;

// @public
export interface AutoChangeDetectionStatus {
    isDisabled: boolean;
    onDetectChangesNow?: () => void;
}

// @public
export interface BaseHarnessFilters {
    ancestor?: string;
    selector?: string;
}

// @public
export abstract class ComponentHarness {
    constructor(locatorFactory: LocatorFactory);
    protected documentRootLocatorFactory(): LocatorFactory;
    protected forceStabilize(): Promise<void>;
    host(): Promise<TestElement>;
    // (undocumented)
    protected readonly locatorFactory: LocatorFactory;
    protected locatorFor<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>>;
    protected locatorForAll<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>[]>;
    protected locatorForOptional<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T> | null>;
    protected waitForTasksOutsideAngular(): Promise<void>;
}

// @public
export interface ComponentHarnessConstructor<T extends ComponentHarness> {
    // (undocumented)
    new (locatorFactory: LocatorFactory): T;
    hostSelector: string;
}

// @public
export abstract class ContentContainerComponentHarness<S extends string = string> extends ComponentHarness implements HarnessLoader {
    // (undocumented)
    getAllChildLoaders(selector: S): Promise<HarnessLoader[]>;
    // (undocumented)
    getAllHarnesses<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T[]>;
    // (undocumented)
    getChildLoader(selector: S): Promise<HarnessLoader>;
    // (undocumented)
    getHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T>;
    // (undocumented)
    getHarnessOrNull<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T | null>;
    protected getRootHarnessLoader(): Promise<HarnessLoader>;
    // (undocumented)
    hasHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<boolean>;
}

// @public
export interface ElementDimensions {
    // (undocumented)
    height: number;
    // (undocumented)
    left: number;
    // (undocumented)
    top: number;
    // (undocumented)
    width: number;
}

// @public
export type EventData = string | number | boolean | Function | undefined | null | EventData[] | {
    [key: string]: EventData;
};

// @public
export function getNoKeysSpecifiedError(): Error;

// @public
export function _getTextWithExcludedElements(element: Element, excludeSelector: string): string;

// @public
export function handleAutoChangeDetectionStatus(handler: (status: AutoChangeDetectionStatus) => void): void;

// @public
export abstract class HarnessEnvironment<E> implements HarnessLoader, LocatorFactory {
    protected constructor(rawRootElement: E);
    protected createComponentHarness<T extends ComponentHarness>(harnessType: ComponentHarnessConstructor<T>, element: E): T;
    protected abstract createEnvironment(element: E): HarnessEnvironment<E>;
    protected abstract createTestElement(element: E): TestElement;
    // (undocumented)
    documentRootLocatorFactory(): LocatorFactory;
    // (undocumented)
    abstract forceStabilize(): Promise<void>;
    // (undocumented)
    getAllChildLoaders(selector: string): Promise<HarnessLoader[]>;
    // (undocumented)
    getAllHarnesses<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T[]>;
    protected abstract getAllRawElements(selector: string): Promise<E[]>;
    // (undocumented)
    getChildLoader(selector: string): Promise<HarnessLoader>;
    protected abstract getDocumentRoot(): E;
    // (undocumented)
    getHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T>;
    // (undocumented)
    getHarnessOrNull<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T | null>;
    // (undocumented)
    harnessLoaderFor(selector: string): Promise<HarnessLoader>;
    // (undocumented)
    harnessLoaderForAll(selector: string): Promise<HarnessLoader[]>;
    // (undocumented)
    harnessLoaderForOptional(selector: string): Promise<HarnessLoader | null>;
    // (undocumented)
    hasHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<boolean>;
    // (undocumented)
    locatorFor<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>>;
    // (undocumented)
    locatorForAll<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>[]>;
    // (undocumented)
    locatorForOptional<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T> | null>;
    // (undocumented)
    protected rawRootElement: E;
    // (undocumented)
    get rootElement(): TestElement;
    set rootElement(element: TestElement);
    // (undocumented)
    rootHarnessLoader(): Promise<HarnessLoader>;
    // (undocumented)
    abstract waitForTasksOutsideAngular(): Promise<void>;
}

// @public
export interface HarnessLoader {
    getAllChildLoaders(selector: string): Promise<HarnessLoader[]>;
    getAllHarnesses<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T[]>;
    getChildLoader(selector: string): Promise<HarnessLoader>;
    getHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T>;
    getHarnessOrNull<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<T | null>;
    hasHarness<T extends ComponentHarness>(query: HarnessQuery<T>): Promise<boolean>;
}

// @public
export class HarnessPredicate<T extends ComponentHarness> {
    constructor(harnessType: ComponentHarnessConstructor<T>, options: BaseHarnessFilters);
    add(description: string, predicate: AsyncPredicate<T>): this;
    addOption<O>(name: string, option: O | undefined, predicate: AsyncOptionPredicate<T, O>): this;
    evaluate(harness: T): Promise<boolean>;
    filter(harnesses: T[]): Promise<T[]>;
    getDescription(): string;
    getSelector(): string;
    // (undocumented)
    harnessType: ComponentHarnessConstructor<T>;
    static stringMatches(value: string | null | Promise<string | null>, pattern: string | RegExp | null): Promise<boolean>;
}

// @public
export type HarnessQuery<T extends ComponentHarness> = ComponentHarnessConstructor<T> | HarnessPredicate<T>;

// @public
export interface LocatorFactory {
    documentRootLocatorFactory(): LocatorFactory;
    forceStabilize(): Promise<void>;
    harnessLoaderFor(selector: string): Promise<HarnessLoader>;
    harnessLoaderForAll(selector: string): Promise<HarnessLoader[]>;
    harnessLoaderForOptional(selector: string): Promise<HarnessLoader | null>;
    locatorFor<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>>;
    locatorForAll<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T>[]>;
    locatorForOptional<T extends (HarnessQuery<any> | string)[]>(...queries: T): AsyncFactoryFn<LocatorFnResult<T> | null>;
    rootElement: TestElement;
    rootHarnessLoader(): Promise<HarnessLoader>;
    waitForTasksOutsideAngular(): Promise<void>;
}

// @public
export type LocatorFnResult<T extends (HarnessQuery<any> | string)[]> = {
    [I in keyof T]: T[I] extends new (...args: any[]) => infer C ? C : T[I] extends {
        harnessType: new (...args: any[]) => infer C;
    } ? C : T[I] extends string ? TestElement : never;
}[number];

// @public
export function manualChangeDetection<T>(fn: () => Promise<T>): Promise<T>;

// @public
export interface ModifierKeys {
    // (undocumented)
    alt?: boolean;
    // (undocumented)
    control?: boolean;
    // (undocumented)
    meta?: boolean;
    // (undocumented)
    shift?: boolean;
}

// @public
export function parallel<T1, T2, T3, T4, T5>(values: () => [
T1 | PromiseLike<T1>,
T2 | PromiseLike<T2>,
T3 | PromiseLike<T3>,
T4 | PromiseLike<T4>,
T5 | PromiseLike<T5>
]): Promise<[T1, T2, T3, T4, T5]>;

// @public
export function parallel<T1, T2, T3, T4>(values: () => [
T1 | PromiseLike<T1>,
T2 | PromiseLike<T2>,
T3 | PromiseLike<T3>,
T4 | PromiseLike<T4>
]): Promise<[T1, T2, T3, T4]>;

// @public
export function parallel<T1, T2, T3>(values: () => [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>]): Promise<[T1, T2, T3]>;

// @public
export function parallel<T1, T2>(values: () => [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>]): Promise<[T1, T2]>;

// @public
export function parallel<T>(values: () => (T | PromiseLike<T>)[]): Promise<T[]>;

// @public
export function stopHandlingAutoChangeDetectionStatus(): void;

// @public
export interface TestElement {
    blur(): Promise<void>;
    clear(): Promise<void>;
    click(modifiers?: ModifierKeys): Promise<void>;
    click(location: 'center', modifiers?: ModifierKeys): Promise<void>;
    click(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;
    dispatchEvent(name: string, data?: Record<string, EventData>): Promise<void>;
    focus(): Promise<void>;
    getAttribute(name: string): Promise<string | null>;
    getCssValue(property: string): Promise<string>;
    getDimensions(): Promise<ElementDimensions>;
    getProperty<T = any>(name: string): Promise<T>;
    hasClass(name: string): Promise<boolean>;
    hover(): Promise<void>;
    isFocused(): Promise<boolean>;
    matchesSelector(selector: string): Promise<boolean>;
    mouseAway(): Promise<void>;
    rightClick(relativeX: number, relativeY: number, modifiers?: ModifierKeys): Promise<void>;
    selectOptions(...optionIndexes: number[]): Promise<void>;
    sendKeys(...keys: (string | TestKey)[]): Promise<void>;
    sendKeys(modifiers: ModifierKeys, ...keys: (string | TestKey)[]): Promise<void>;
    setContenteditableValue?(value: string): Promise<void>;
    setInputValue(value: string): Promise<void>;
    text(options?: TextOptions): Promise<string>;
}

// @public
export enum TestKey {
    // (undocumented)
    ALT = 5,
    // (undocumented)
    BACKSPACE = 0,
    // (undocumented)
    COMMA = 30,
    // (undocumented)
    CONTROL = 4,
    // (undocumented)
    DELETE = 16,
    // (undocumented)
    DOWN_ARROW = 14,
    // (undocumented)
    END = 9,
    // (undocumented)
    ENTER = 2,
    // (undocumented)
    ESCAPE = 6,
    // (undocumented)
    F1 = 17,
    // (undocumented)
    F10 = 26,
    // (undocumented)
    F11 = 27,
    // (undocumented)
    F12 = 28,
    // (undocumented)
    F2 = 18,
    // (undocumented)
    F3 = 19,
    // (undocumented)
    F4 = 20,
    // (undocumented)
    F5 = 21,
    // (undocumented)
    F6 = 22,
    // (undocumented)
    F7 = 23,
    // (undocumented)
    F8 = 24,
    // (undocumented)
    F9 = 25,
    // (undocumented)
    HOME = 10,
    // (undocumented)
    INSERT = 15,
    // (undocumented)
    LEFT_ARROW = 11,
    // (undocumented)
    META = 29,
    // (undocumented)
    PAGE_DOWN = 8,
    // (undocumented)
    PAGE_UP = 7,
    // (undocumented)
    RIGHT_ARROW = 13,
    // (undocumented)
    SHIFT = 3,
    // (undocumented)
    TAB = 1,
    // (undocumented)
    UP_ARROW = 12
}

// @public (undocumented)
export interface TextOptions {
    exclude?: string;
}

// (No @packageDocumentation comment for this package)

```
