## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentChecked } from '@angular/core';
import { AfterContentInit } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { ChangeDetectorRef } from '@angular/core';
import { CollectionViewer } from '@angular/cdk/collections';
import { DataSource } from '@angular/cdk/collections';
import { Direction } from '@angular/cdk/bidi';
import { Directionality } from '@angular/cdk/bidi';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import * as i0 from '@angular/core';
import * as i1 from '@angular/cdk/scrolling';
import { InjectionToken } from '@angular/core';
import { Injector } from '@angular/core';
import { IterableChanges } from '@angular/core';
import { IterableDiffer } from '@angular/core';
import { IterableDiffers } from '@angular/core';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { QueryList } from '@angular/core';
import { SimpleChanges } from '@angular/core';
import { TemplateRef } from '@angular/core';
import { TrackByFunction } from '@angular/core';
import { ViewContainerRef } from '@angular/core';
import { _ViewRepeater } from '@angular/cdk/collections';

// @public
export class BaseCdkCell {
    constructor(columnDef: CdkColumnDef, elementRef: ElementRef);
}

// @public
export abstract class BaseRowDef implements OnChanges {
    constructor(...args: unknown[]);
    columns: Iterable<string>;
    protected _columnsDiffer: IterableDiffer<any>;
    // (undocumented)
    protected _differs: IterableDiffers;
    extractCellTemplate(column: CdkColumnDef): TemplateRef<any>;
    getColumnsDiff(): IterableChanges<any> | null;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    // (undocumented)
    template: TemplateRef<any>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<BaseRowDef, never, never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<BaseRowDef, never>;
}

// @public
export interface CanStick {
    hasStickyChanged(): boolean;
    resetStickyChanged(): void;
    sticky: boolean;
}

// @public
export type CanStickCtor = Constructor<CanStick>;

// @public
export const CDK_ROW_TEMPLATE = "<ng-container cdkCellOutlet></ng-container>";

// @public
export const CDK_TABLE: InjectionToken<any>;

// @public
export const CDK_TABLE_TEMPLATE = "\n  <ng-content select=\"caption\"/>\n  <ng-content select=\"colgroup, col\"/>\n\n  <!--\n    Unprojected content throws a hydration error so we need this to capture it.\n    It gets removed on the client so it doesn't affect the layout.\n  -->\n  @if (_isServer) {\n    <ng-content/>\n  }\n\n  @if (_isNativeHtmlTable) {\n    <thead role=\"rowgroup\">\n      <ng-container headerRowOutlet/>\n    </thead>\n    <tbody role=\"rowgroup\">\n      <ng-container rowOutlet/>\n      <ng-container noDataRowOutlet/>\n    </tbody>\n    <tfoot role=\"rowgroup\">\n      <ng-container footerRowOutlet/>\n    </tfoot>\n  } @else {\n    <ng-container headerRowOutlet/>\n    <ng-container rowOutlet/>\n    <ng-container noDataRowOutlet/>\n    <ng-container footerRowOutlet/>\n  }\n";

// @public
export class CdkCell extends BaseCdkCell {
    constructor(...args: unknown[]);
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkCell, "cdk-cell, td[cdk-cell]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkCell, never>;
}

// @public
export class CdkCellDef implements CellDef {
    constructor(...args: unknown[]);
    template: TemplateRef<any>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkCellDef, "[cdkCellDef]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkCellDef, never>;
}

// @public
export class CdkCellOutlet implements OnDestroy {
    constructor(...args: unknown[]);
    cells: CdkCellDef[];
    context: any;
    static mostRecentCellOutlet: CdkCellOutlet | null;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    _viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkCellOutlet, "[cdkCellOutlet]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkCellOutlet, never>;
}

// @public
export interface CdkCellOutletMultiRowContext<T> {
    $implicit?: T;
    count?: number;
    dataIndex?: number;
    even?: boolean;
    first?: boolean;
    last?: boolean;
    odd?: boolean;
    renderIndex?: number;
}

// @public
export interface CdkCellOutletRowContext<T> {
    $implicit?: T;
    count?: number;
    even?: boolean;
    first?: boolean;
    index?: number;
    last?: boolean;
    odd?: boolean;
}

// @public
export class CdkColumnDef implements CanStick {
    constructor(...args: unknown[]);
    cell: CdkCellDef;
    _columnCssClassName: string[];
    cssClassFriendlyName: string;
    footerCell: CdkFooterCellDef;
    hasStickyChanged(): boolean;
    headerCell: CdkHeaderCellDef;
    get name(): string;
    set name(name: string);
    // (undocumented)
    protected _name: string;
    // (undocumented)
    static ngAcceptInputType_sticky: unknown;
    // (undocumented)
    static ngAcceptInputType_stickyEnd: unknown;
    resetStickyChanged(): void;
    protected _setNameInput(value: string): void;
    get sticky(): boolean;
    set sticky(value: boolean);
    get stickyEnd(): boolean;
    set stickyEnd(value: boolean);
    // (undocumented)
    _stickyEnd: boolean;
    // (undocumented)
    _table?: any;
    protected _updateColumnCssClassName(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkColumnDef, "[cdkColumnDef]", never, { "name": { "alias": "cdkColumnDef"; "required": false; }; "sticky": { "alias": "sticky"; "required": false; }; "stickyEnd": { "alias": "stickyEnd"; "required": false; }; }, {}, ["cell", "headerCell", "footerCell"], never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkColumnDef, never>;
}

// @public
export class CdkFooterCell extends BaseCdkCell {
    constructor(...args: unknown[]);
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFooterCell, "cdk-footer-cell, td[cdk-footer-cell]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterCell, never>;
}

// @public
export class CdkFooterCellDef implements CellDef {
    constructor(...args: unknown[]);
    template: TemplateRef<any>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFooterCellDef, "[cdkFooterCellDef]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterCellDef, never>;
}

// @public
export class CdkFooterRow {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkFooterRow, "cdk-footer-row, tr[cdk-footer-row]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterRow, never>;
}

// @public
export class CdkFooterRowDef extends BaseRowDef implements CanStick, OnChanges {
    constructor(...args: unknown[]);
    hasStickyChanged(): boolean;
    // (undocumented)
    static ngAcceptInputType_sticky: unknown;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    resetStickyChanged(): void;
    get sticky(): boolean;
    set sticky(value: boolean);
    // (undocumented)
    _table?: any;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFooterRowDef, "[cdkFooterRowDef]", never, { "columns": { "alias": "cdkFooterRowDef"; "required": false; }; "sticky": { "alias": "cdkFooterRowDefSticky"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFooterRowDef, never>;
}

// @public
export class CdkHeaderCell extends BaseCdkCell {
    constructor(...args: unknown[]);
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkHeaderCell, "cdk-header-cell, th[cdk-header-cell]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderCell, never>;
}

// @public
export class CdkHeaderCellDef implements CellDef {
    constructor(...args: unknown[]);
    template: TemplateRef<any>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkHeaderCellDef, "[cdkHeaderCellDef]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderCellDef, never>;
}

// @public
export class CdkHeaderRow {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkHeaderRow, "cdk-header-row, tr[cdk-header-row]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderRow, never>;
}

// @public
export class CdkHeaderRowDef extends BaseRowDef implements CanStick, OnChanges {
    constructor(...args: unknown[]);
    hasStickyChanged(): boolean;
    // (undocumented)
    static ngAcceptInputType_sticky: unknown;
    // (undocumented)
    ngOnChanges(changes: SimpleChanges): void;
    resetStickyChanged(): void;
    get sticky(): boolean;
    set sticky(value: boolean);
    // (undocumented)
    _table?: any;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkHeaderRowDef, "[cdkHeaderRowDef]", never, { "columns": { "alias": "cdkHeaderRowDef"; "required": false; }; "sticky": { "alias": "cdkHeaderRowDefSticky"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkHeaderRowDef, never>;
}

// @public
export class CdkNoDataRow {
    constructor(...args: unknown[]);
    // (undocumented)
    _contentClassName: string;
    // (undocumented)
    templateRef: TemplateRef<any>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkNoDataRow, "ng-template[cdkNoDataRow]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkNoDataRow, never>;
}

// @public
export class CdkRecycleRows {
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkRecycleRows, "cdk-table[recycleRows], table[cdk-table][recycleRows]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkRecycleRows, never>;
}

// @public
export class CdkRow {
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkRow, "cdk-row, tr[cdk-row]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkRow, never>;
}

// @public
export class CdkRowDef<T> extends BaseRowDef {
    constructor(...args: unknown[]);
    // (undocumented)
    _table?: any;
    when: (index: number, rowData: T) => boolean;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkRowDef<any>, "[cdkRowDef]", never, { "columns": { "alias": "cdkRowDefColumns"; "required": false; }; "when": { "alias": "cdkRowDefWhen"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkRowDef<any>, never>;
}

// @public
export class CdkTable<T> implements AfterContentInit, AfterContentChecked, CollectionViewer, OnDestroy, OnInit {
    constructor(...args: unknown[]);
    addColumnDef(columnDef: CdkColumnDef): void;
    addFooterRowDef(footerRowDef: CdkFooterRowDef): void;
    addHeaderRowDef(headerRowDef: CdkHeaderRowDef): void;
    addRowDef(rowDef: CdkRowDef<T>): void;
    // (undocumented)
    protected readonly _changeDetectorRef: ChangeDetectorRef;
    // (undocumented)
    protected readonly _coalescedStyleScheduler: _CoalescedStyleScheduler;
    readonly contentChanged: EventEmitter<void>;
    _contentColumnDefs: QueryList<CdkColumnDef>;
    _contentFooterRowDefs: QueryList<CdkFooterRowDef>;
    _contentHeaderRowDefs: QueryList<CdkHeaderRowDef>;
    _contentRowDefs: QueryList<CdkRowDef<T>>;
    protected _data: readonly T[];
    get dataSource(): CdkTableDataSourceInput<T>;
    set dataSource(dataSource: CdkTableDataSourceInput<T>);
    // (undocumented)
    protected readonly _differs: IterableDiffers;
    // (undocumented)
    protected readonly _dir: Directionality | null;
    // (undocumented)
    protected readonly _elementRef: ElementRef<any>;
    get fixedLayout(): boolean;
    set fixedLayout(value: boolean);
    // (undocumented)
    _footerRowOutlet: FooterRowOutlet;
    _getCellRole(): string | null;
    _getRenderedRows(rowOutlet: RowOutlet): HTMLElement[];
    _getRowDefs(data: T, dataIndex: number): CdkRowDef<T>[];
    // (undocumented)
    _headerRowOutlet: HeaderRowOutlet;
    protected _isNativeHtmlTable: boolean;
    protected _isServer: boolean;
    get multiTemplateDataRows(): boolean;
    set multiTemplateDataRows(value: boolean);
    // (undocumented)
    _multiTemplateDataRows: boolean;
    protected needsPositionStickyOnElement: boolean;
    // (undocumented)
    static ngAcceptInputType_fixedLayout: unknown;
    // (undocumented)
    static ngAcceptInputType_multiTemplateDataRows: unknown;
    // (undocumented)
    ngAfterContentChecked(): void;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    _noDataRow: CdkNoDataRow;
    // (undocumented)
    _noDataRowOutlet: NoDataRowOutlet;
    _outletAssigned(): void;
    removeColumnDef(columnDef: CdkColumnDef): void;
    removeFooterRowDef(footerRowDef: CdkFooterRowDef): void;
    removeHeaderRowDef(headerRowDef: CdkHeaderRowDef): void;
    removeRowDef(rowDef: CdkRowDef<T>): void;
    renderRows(): void;
    // (undocumented)
    _rowOutlet: DataRowOutlet;
    setNoDataRow(noDataRow: CdkNoDataRow | null): void;
    protected stickyCssClass: string;
    // (undocumented)
    protected readonly _stickyPositioningListener: StickyPositioningListener;
    get trackBy(): TrackByFunction<T>;
    set trackBy(fn: TrackByFunction<T>);
    updateStickyColumnStyles(): void;
    updateStickyFooterRowStyles(): void;
    updateStickyHeaderRowStyles(): void;
    readonly viewChange: BehaviorSubject<{
        start: number;
        end: number;
    }>;
    // (undocumented)
    protected readonly _viewRepeater: _ViewRepeater<T, RenderRow<T>, RowContext<T>>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTable<any>, "cdk-table, table[cdk-table]", ["cdkTable"], { "trackBy": { "alias": "trackBy"; "required": false; }; "dataSource": { "alias": "dataSource"; "required": false; }; "multiTemplateDataRows": { "alias": "multiTemplateDataRows"; "required": false; }; "fixedLayout": { "alias": "fixedLayout"; "required": false; }; }, { "contentChanged": "contentChanged"; }, ["_noDataRow", "_contentColumnDefs", "_contentRowDefs", "_contentHeaderRowDefs", "_contentFooterRowDefs"], ["caption", "colgroup, col", "*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTable<any>, never>;
}

// @public
export type CdkTableDataSourceInput<T> = readonly T[] | DataSource<T> | Observable<readonly T[]>;

// @public (undocumented)
export class CdkTableModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTableModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<CdkTableModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkTableModule, never, [typeof i1.ScrollingModule, typeof i2.CdkTable, typeof i3.CdkRowDef, typeof i4.CdkCellDef, typeof i3.CdkCellOutlet, typeof i4.CdkHeaderCellDef, typeof i4.CdkFooterCellDef, typeof i4.CdkColumnDef, typeof i4.CdkCell, typeof i3.CdkRow, typeof i4.CdkHeaderCell, typeof i4.CdkFooterCell, typeof i3.CdkHeaderRow, typeof i3.CdkHeaderRowDef, typeof i3.CdkFooterRow, typeof i3.CdkFooterRowDef, typeof i2.DataRowOutlet, typeof i2.HeaderRowOutlet, typeof i2.FooterRowOutlet, typeof i5.CdkTextColumn, typeof i3.CdkNoDataRow, typeof i2.CdkRecycleRows, typeof i2.NoDataRowOutlet], [typeof i2.CdkTable, typeof i3.CdkRowDef, typeof i4.CdkCellDef, typeof i3.CdkCellOutlet, typeof i4.CdkHeaderCellDef, typeof i4.CdkFooterCellDef, typeof i4.CdkColumnDef, typeof i4.CdkCell, typeof i3.CdkRow, typeof i4.CdkHeaderCell, typeof i4.CdkFooterCell, typeof i3.CdkHeaderRow, typeof i3.CdkHeaderRowDef, typeof i3.CdkFooterRow, typeof i3.CdkFooterRowDef, typeof i2.DataRowOutlet, typeof i2.HeaderRowOutlet, typeof i2.FooterRowOutlet, typeof i5.CdkTextColumn, typeof i3.CdkNoDataRow, typeof i2.CdkRecycleRows, typeof i2.NoDataRowOutlet]>;
}

// @public
export class CdkTextColumn<T> implements OnDestroy, OnInit {
    constructor(...args: unknown[]);
    cell: CdkCellDef;
    columnDef: CdkColumnDef;
    _createDefaultHeaderText(): string;
    dataAccessor: (data: T, name: string) => string;
    headerCell: CdkHeaderCellDef;
    headerText: string;
    justify: 'start' | 'end' | 'center';
    get name(): string;
    set name(name: string);
    // (undocumented)
    _name: string;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTextColumn<any>, "cdk-text-column", never, { "name": { "alias": "name"; "required": false; }; "headerText": { "alias": "headerText"; "required": false; }; "dataAccessor": { "alias": "dataAccessor"; "required": false; }; "justify": { "alias": "justify"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTextColumn<any>, never>;
}

// @public
export interface CellDef {
    // (undocumented)
    template: TemplateRef<any>;
}

// @public
export const _COALESCED_STYLE_SCHEDULER: InjectionToken<_CoalescedStyleScheduler>;

// @public
export class _CoalescedStyleScheduler {
    constructor(...args: unknown[]);
    schedule(task: () => unknown): void;
    scheduleEnd(task: () => unknown): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<_CoalescedStyleScheduler, never>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<_CoalescedStyleScheduler>;
}

// @public
export type Constructor<T> = new (...args: any[]) => T;

// @public
export class DataRowOutlet implements RowOutlet {
    constructor(...args: unknown[]);
    // (undocumented)
    elementRef: ElementRef<any>;
    // (undocumented)
    viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<DataRowOutlet, "[rowOutlet]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<DataRowOutlet, never>;
}

export { DataSource }

// @public
export class FooterRowOutlet implements RowOutlet {
    constructor(...args: unknown[]);
    // (undocumented)
    elementRef: ElementRef<any>;
    // (undocumented)
    viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<FooterRowOutlet, "[footerRowOutlet]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<FooterRowOutlet, never>;
}

// @public
export class HeaderRowOutlet implements RowOutlet {
    constructor(...args: unknown[]);
    // (undocumented)
    elementRef: ElementRef<any>;
    // (undocumented)
    viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<HeaderRowOutlet, "[headerRowOutlet]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<HeaderRowOutlet, never>;
}

// @public @deprecated
export function mixinHasStickyInput<T extends Constructor<{}>>(base: T): CanStickCtor & T;

// @public
export class NoDataRowOutlet implements RowOutlet {
    constructor(...args: unknown[]);
    // (undocumented)
    elementRef: ElementRef<any>;
    // (undocumented)
    viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<NoDataRowOutlet, "[noDataRowOutlet]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<NoDataRowOutlet, never>;
}

// @public
export interface RenderRow<T> {
    // (undocumented)
    data: T;
    // (undocumented)
    dataIndex: number;
    // (undocumented)
    rowDef: CdkRowDef<T>;
}

// @public
export interface RowContext<T> extends CdkCellOutletMultiRowContext<T>, CdkCellOutletRowContext<T> {
}

// @public
export interface RowOutlet {
    // (undocumented)
    viewContainer: ViewContainerRef;
}

// @public
export class _Schedule {
    // (undocumented)
    endTasks: (() => unknown)[];
    // (undocumented)
    tasks: (() => unknown)[];
}

// @public
export const STICKY_DIRECTIONS: StickyDirection[];

// @public
export const STICKY_POSITIONING_LISTENER: InjectionToken<StickyPositioningListener>;

// @public (undocumented)
export type StickyDirection = 'top' | 'bottom' | 'left' | 'right';

// @public (undocumented)
export type StickyOffset = number | null | undefined;

// @public
export interface StickyPositioningListener {
    stickyColumnsUpdated(update: StickyUpdate): void;
    stickyEndColumnsUpdated(update: StickyUpdate): void;
    stickyFooterRowsUpdated(update: StickyUpdate): void;
    stickyHeaderRowsUpdated(update: StickyUpdate): void;
}

// @public (undocumented)
export type StickySize = number | null | undefined;

// @public
export class StickyStyler {
    constructor(_isNativeHtmlTable: boolean, _stickCellCss: string, direction: Direction, _coalescedStyleScheduler: _CoalescedStyleScheduler, _isBrowser?: boolean, _needsPositionStickyOnElement?: boolean, _positionListener?: StickyPositioningListener | undefined, _tableInjector?: Injector | undefined);
    _addStickyStyle(element: HTMLElement, dir: StickyDirection, dirValue: number, isBorderElement: boolean): void;
    clearStickyPositioning(rows: HTMLElement[], stickyDirections: StickyDirection[]): void;
    destroy(): void;
    // (undocumented)
    direction: Direction;
    _getCalculatedZIndex(element: HTMLElement): string;
    _getCellWidths(row: HTMLElement, recalculateCellWidths?: boolean): number[];
    _getStickyEndColumnPositions(widths: number[], stickyStates: boolean[]): number[];
    _getStickyStartColumnPositions(widths: number[], stickyStates: boolean[]): number[];
    _removeStickyStyle(element: HTMLElement, stickyDirections: StickyDirection[]): void;
    stickRows(rowsToStick: HTMLElement[], stickyStates: boolean[], position: 'top' | 'bottom'): void;
    updateStickyColumns(rows: HTMLElement[], stickyStartStates: boolean[], stickyEndStates: boolean[], recalculateCellWidths?: boolean, replay?: boolean): void;
    updateStickyFooterContainer(tableElement: Element, stickyStates: boolean[]): void;
}

// @public (undocumented)
export interface StickyUpdate {
    // (undocumented)
    elements?: readonly (HTMLElement[] | undefined)[];
    // (undocumented)
    offsets?: StickyOffset[];
    // (undocumented)
    sizes: StickySize[];
}

// @public
export const TEXT_COLUMN_OPTIONS: InjectionToken<TextColumnOptions<any>>;

// @public
export interface TextColumnOptions<T> {
    defaultDataAccessor?: (data: T, name: string) => string;
    defaultHeaderTextTransform?: (name: string) => string;
}

// (No @packageDocumentation comment for this package)

```
