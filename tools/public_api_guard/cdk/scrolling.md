## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { ChangeDetectorRef } from '@angular/core';
import { CollectionViewer } from '@angular/cdk/collections';
import { DataSource } from '@angular/cdk/collections';
import { Directionality } from '@angular/cdk/bidi';
import { DoCheck } from '@angular/core';
import { ElementRef } from '@angular/core';
import * as i0 from '@angular/core';
import * as i2 from '@angular/cdk/bidi';
import { InjectionToken } from '@angular/core';
import { IterableDiffers } from '@angular/core';
import { ListRange } from '@angular/cdk/collections';
import { NgIterable } from '@angular/core';
import { NgZone } from '@angular/core';
import { NumberInput } from '@angular/cdk/coercion';
import { Observable } from 'rxjs';
import { OnChanges } from '@angular/core';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { Platform } from '@angular/cdk/platform';
import { _RecycleViewRepeaterStrategy } from '@angular/cdk/collections';
import { Subject } from 'rxjs';
import { Subscription } from 'rxjs';
import { TemplateRef } from '@angular/core';
import { TrackByFunction } from '@angular/core';
import { ViewContainerRef } from '@angular/core';

// @public (undocumented)
export type _Bottom = {
    bottom?: number;
};

// @public
export class CdkFixedSizeVirtualScroll implements OnChanges {
    get itemSize(): number;
    set itemSize(value: NumberInput);
    // (undocumented)
    _itemSize: number;
    get maxBufferPx(): number;
    set maxBufferPx(value: NumberInput);
    // (undocumented)
    _maxBufferPx: number;
    get minBufferPx(): number;
    set minBufferPx(value: NumberInput);
    // (undocumented)
    _minBufferPx: number;
    // (undocumented)
    ngOnChanges(): void;
    _scrollStrategy: FixedSizeVirtualScrollStrategy;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkFixedSizeVirtualScroll, "cdk-virtual-scroll-viewport[itemSize]", never, { "itemSize": { "alias": "itemSize"; "required": false; }; "minBufferPx": { "alias": "minBufferPx"; "required": false; }; "maxBufferPx": { "alias": "maxBufferPx"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkFixedSizeVirtualScroll, never>;
}

// @public
export class CdkMultiColumnsVirtualScroll implements OnChanges {
    get itemDimension(): ItemDimension;
    set itemDimension(val: ItemDimension);
    // (undocumented)
    _itemDimension: ItemDimension;
    get maxBufferPx(): number;
    set maxBufferPx(value: NumberInput);
    // (undocumented)
    _maxBufferPx: number;
    get minBufferPx(): number;
    set minBufferPx(value: NumberInput);
    // (undocumented)
    _minBufferPx: number;
    // (undocumented)
    ngOnChanges(): void;
    _scrollStrategy: MultiColumnVirtualScrollStrategy;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkMultiColumnsVirtualScroll, "cdk-virtual-scroll-viewport[itemDimension]", never, { "itemDimension": { "alias": "itemDimension"; "required": false; }; "minBufferPx": { "alias": "minBufferPx"; "required": false; }; "maxBufferPx": { "alias": "maxBufferPx"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkMultiColumnsVirtualScroll, never>;
}

// @public
export class CdkScrollable implements OnInit, OnDestroy {
    constructor(elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir?: Directionality | undefined);
    // (undocumented)
    protected readonly _destroyed: Subject<void>;
    // (undocumented)
    protected dir?: Directionality | undefined;
    // (undocumented)
    protected elementRef: ElementRef<HTMLElement>;
    elementScrolled(): Observable<Event>;
    // (undocumented)
    protected _elementScrolled: Observable<Event>;
    getElementRef(): ElementRef<HTMLElement>;
    measureScrollOffset(from: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    protected ngZone: NgZone;
    // (undocumented)
    protected scrollDispatcher: ScrollDispatcher;
    scrollTo(options: ExtendedScrollToOptions): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkScrollable, "[cdk-scrollable], [cdkScrollable]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkScrollable, [null, null, null, { optional: true; }]>;
}

// @public (undocumented)
export class CdkScrollableModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkScrollableModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<CdkScrollableModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkScrollableModule, never, [typeof i1.CdkScrollable], [typeof i1.CdkScrollable]>;
}

// @public
export class CdkVirtualForOf<T> implements CdkVirtualScrollRepeater<T>, CollectionViewer, DoCheck, OnDestroy {
    constructor(
    _viewContainerRef: ViewContainerRef,
    _template: TemplateRef<CdkVirtualForOfContext<T>>,
    _differs: IterableDiffers,
    _viewRepeater: _RecycleViewRepeaterStrategy<T, T, CdkVirtualForOfContext<T>>,
    _viewport: CdkVirtualScrollViewport, ngZone: NgZone);
    get cdkVirtualForOf(): DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined;
    set cdkVirtualForOf(value: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined);
    // (undocumented)
    _cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T> | null | undefined;
    set cdkVirtualForTemplate(value: TemplateRef<CdkVirtualForOfContext<T>>);
    get cdkVirtualForTemplateCacheSize(): number;
    set cdkVirtualForTemplateCacheSize(size: NumberInput);
    get cdkVirtualForTrackBy(): TrackByFunction<T> | undefined;
    set cdkVirtualForTrackBy(fn: TrackByFunction<T> | undefined);
    readonly dataStream: Observable<readonly T[]>;
    measureRangeSize(range: ListRange, orientation: 'horizontal' | 'vertical'): number;
    // (undocumented)
    ngDoCheck(): void;
    // (undocumented)
    ngOnDestroy(): void;
    readonly viewChange: Subject<ListRange>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualForOf<any>, "[cdkVirtualFor][cdkVirtualForOf]", never, { "cdkVirtualForOf": { "alias": "cdkVirtualForOf"; "required": false; }; "cdkVirtualForTrackBy": { "alias": "cdkVirtualForTrackBy"; "required": false; }; "cdkVirtualForTemplate": { "alias": "cdkVirtualForTemplate"; "required": false; }; "cdkVirtualForTemplateCacheSize": { "alias": "cdkVirtualForTemplateCacheSize"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualForOf<any>, [null, null, null, null, { skipSelf: true; }, null]>;
}

// @public
export type CdkVirtualForOfContext<T> = {
    $implicit: T;
    cdkVirtualForOf: DataSource<T> | Observable<T[]> | NgIterable<T>;
    index: number;
    count: number;
    first: boolean;
    last: boolean;
    even: boolean;
    odd: boolean;
};

// @public
export abstract class CdkVirtualScrollable extends CdkScrollable {
    constructor(elementRef: ElementRef<HTMLElement>, scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir?: Directionality);
    abstract measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;
    measureViewportSize(orientation: 'horizontal' | 'vertical'): number;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualScrollable, never, never, {}, {}, never, never, false, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollable, [null, null, null, { optional: true; }]>;
}

// @public
export class CdkVirtualScrollableElement extends CdkVirtualScrollable {
    constructor(elementRef: ElementRef, scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir: Directionality);
    // (undocumented)
    measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualScrollableElement, "[cdkVirtualScrollingElement]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollableElement, [null, null, null, { optional: true; }]>;
}

// @public
export class CdkVirtualScrollableWindow extends CdkVirtualScrollable {
    constructor(scrollDispatcher: ScrollDispatcher, ngZone: NgZone, dir: Directionality);
    // (undocumented)
    protected _elementScrolled: Observable<Event>;
    // (undocumented)
    measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkVirtualScrollableWindow, "cdk-virtual-scroll-viewport[scrollWindow]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollableWindow, [null, null, { optional: true; }]>;
}

// @public
export interface CdkVirtualScrollRepeater<T> {
    // (undocumented)
    readonly dataStream: Observable<readonly T[]>;
    // (undocumented)
    measureRangeSize(range: ListRange, orientation: 'horizontal' | 'vertical'): number;
}

// @public
export class CdkVirtualScrollViewport extends CdkVirtualScrollable implements OnInit, OnDestroy {
    constructor(elementRef: ElementRef<HTMLElement>, _changeDetectorRef: ChangeDetectorRef, ngZone: NgZone, _scrollStrategy: VirtualScrollStrategy, dir: Directionality, scrollDispatcher: ScrollDispatcher, viewportRuler: ViewportRuler, scrollable: CdkVirtualScrollable);
    appendOnly: boolean;
    attach(forOf: CdkVirtualScrollRepeater<any>): void;
    checkViewportSize(): void;
    _contentWrapper: ElementRef<HTMLElement>;
    detach(): void;
    // (undocumented)
    elementRef: ElementRef<HTMLElement>;
    getDataLength(): number;
    getOffsetToRenderedContentStart(): number | null;
    getRenderedRange(): ListRange;
    getViewportSize(): number;
    // (undocumented)
    measureBoundingClientRectWithScrollOffset(from: 'left' | 'top' | 'right' | 'bottom'): number;
    measureRangeSize(range: ListRange): number;
    measureRenderedContentSize(): number;
    measureScrollOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;
    measureViewportOffset(from?: 'top' | 'left' | 'right' | 'bottom' | 'start' | 'end'): number;
    // (undocumented)
    static ngAcceptInputType_appendOnly: unknown;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    get orientation(): 'horizontal' | 'vertical';
    set orientation(orientation: 'horizontal' | 'vertical');
    readonly renderedRangeStream: Observable<ListRange>;
    // (undocumented)
    scrollable: CdkVirtualScrollable;
    readonly scrolledIndexChange: Observable<number>;
    scrollToIndex(index: number, behavior?: ScrollBehavior): void;
    scrollToOffset(offset: number, behavior?: ScrollBehavior): void;
    setRenderedContentOffset(offset: number, to?: 'to-start' | 'to-end'): void;
    setRenderedRange(range: ListRange): void;
    setTotalContentSize(size: number): void;
    _totalContentHeight: string;
    _totalContentWidth: string;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkVirtualScrollViewport, "cdk-virtual-scroll-viewport", never, { "orientation": { "alias": "orientation"; "required": false; }; "appendOnly": { "alias": "appendOnly"; "required": false; }; }, { "scrolledIndexChange": "scrolledIndexChange"; }, never, ["*"], true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkVirtualScrollViewport, [null, null, null, { optional: true; }, { optional: true; }, null, null, { optional: true; }]>;
}

// @public
export const DEFAULT_RESIZE_TIME = 20;

// @public
export const DEFAULT_SCROLL_TIME = 20;

// @public (undocumented)
export type _End = {
    end?: number;
};

// @public
export type ExtendedScrollToOptions = _XAxis & _YAxis & ScrollOptions;

// @public
export class FixedSizeVirtualScrollStrategy implements VirtualScrollStrategy {
    constructor(itemSize: number, minBufferPx: number, maxBufferPx: number);
    attach(viewport: CdkVirtualScrollViewport): void;
    detach(): void;
    onContentRendered(): void;
    onContentScrolled(): void;
    onDataLengthChanged(): void;
    onRenderedOffsetChanged(): void;
    scrolledIndexChange: Observable<number>;
    scrollToIndex(index: number, behavior: ScrollBehavior): void;
    updateItemAndBufferSize(itemSize: number, minBufferPx: number, maxBufferPx: number): void;
}

// @public
export function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir: CdkFixedSizeVirtualScroll): FixedSizeVirtualScrollStrategy;

// @public (undocumented)
export class ItemDimension {
    // (undocumented)
    height: number;
    // (undocumented)
    width: number | string;
}

// @public (undocumented)
export type _Left = {
    left?: number;
};

// @public (undocumented)
export class MultiColumnVirtualScrollStrategy implements VirtualScrollStrategy {
    constructor(itemDimension: ItemDimension, minBufferPx: number, maxBufferPx: number);
    attach(viewport: CdkVirtualScrollViewport): void;
    detach(): void;
    onContentRendered(): void;
    onContentScrolled(): void;
    onDataLengthChanged(): void;
    onRenderedOffsetChanged(): void;
    scrolledIndexChange: Observable<number>;
    scrollToIndex(dataIndex: number, behavior: ScrollBehavior): void;
    updateItemAndBufferSize(itemSize: ItemDimension, minBufferPx: number, maxBufferPx: number): void;
}

// @public
export function _multiColumnVirtualScrollStrategyFactory(multiColumnsDir: CdkMultiColumnsVirtualScroll): MultiColumnVirtualScrollStrategy;

// @public (undocumented)
export type _Right = {
    right?: number;
};

// @public
export class ScrollDispatcher implements OnDestroy {
    constructor(_ngZone: NgZone, _platform: Platform, document: any);
    ancestorScrolled(elementOrElementRef: ElementRef | HTMLElement, auditTimeInMs?: number): Observable<CdkScrollable | void>;
    deregister(scrollable: CdkScrollable): void;
    protected _document: Document;
    getAncestorScrollContainers(elementOrElementRef: ElementRef | HTMLElement): CdkScrollable[];
    _globalSubscription: Subscription | null;
    // (undocumented)
    ngOnDestroy(): void;
    register(scrollable: CdkScrollable): void;
    scrollContainers: Map<CdkScrollable, Subscription>;
    scrolled(auditTimeInMs?: number): Observable<CdkScrollable | void>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ScrollDispatcher, [null, null, { optional: true; }]>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ScrollDispatcher>;
}

// @public
export class ScrollingModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ScrollingModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<ScrollingModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<ScrollingModule, never, [typeof i2.BidiModule, typeof CdkScrollableModule, typeof i3.CdkVirtualScrollViewport, typeof i4.CdkFixedSizeVirtualScroll, typeof i5.CdkMultiColumnsVirtualScroll, typeof i6.CdkVirtualForOf, typeof i7.CdkVirtualScrollableWindow, typeof i8.CdkVirtualScrollableElement], [typeof i2.BidiModule, typeof CdkScrollableModule, typeof i4.CdkFixedSizeVirtualScroll, typeof i5.CdkMultiColumnsVirtualScroll, typeof i6.CdkVirtualForOf, typeof i3.CdkVirtualScrollViewport, typeof i7.CdkVirtualScrollableWindow, typeof i8.CdkVirtualScrollableElement]>;
}

// @public (undocumented)
export type _Start = {
    start?: number;
};

// @public (undocumented)
export type _Top = {
    top?: number;
};

// @public
export class ViewportRuler implements OnDestroy {
    constructor(_platform: Platform, ngZone: NgZone, document: any);
    change(throttleTime?: number): Observable<Event>;
    protected _document: Document;
    getViewportRect(): {
        top: number;
        left: number;
        bottom: number;
        right: number;
        height: number;
        width: number;
    };
    getViewportScrollPosition(): ViewportScrollPosition;
    getViewportSize(): Readonly<{
        width: number;
        height: number;
    }>;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<ViewportRuler, [null, null, { optional: true; }]>;
    // (undocumented)
    static ɵprov: i0.ɵɵInjectableDeclaration<ViewportRuler>;
}

// @public
export interface ViewportScrollPosition {
    // (undocumented)
    left: number;
    // (undocumented)
    top: number;
}

// @public
export const VIRTUAL_SCROLL_STRATEGY: InjectionToken<VirtualScrollStrategy>;

// @public (undocumented)
export const VIRTUAL_SCROLLABLE: InjectionToken<CdkVirtualScrollable>;

// @public
export interface VirtualScrollStrategy {
    attach(viewport: CdkVirtualScrollViewport): void;
    detach(): void;
    onContentRendered(): void;
    onContentScrolled(): void;
    onDataLengthChanged(): void;
    onRenderedOffsetChanged(): void;
    scrolledIndexChange: Observable<number>;
    scrollToIndex(index: number, behavior: ScrollBehavior): void;
}

// @public (undocumented)
export type _Without<T> = {
    [P in keyof T]?: never;
};

// @public (undocumented)
export type _XAxis = _XOR<_XOR<_Left, _Right>, _XOR<_Start, _End>>;

// @public (undocumented)
export type _XOR<T, U> = (_Without<T> & U) | (_Without<U> & T);

// @public (undocumented)
export type _YAxis = _XOR<_Top, _Bottom>;

// (No @packageDocumentation comment for this package)

```
