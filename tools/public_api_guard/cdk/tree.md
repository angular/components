## API Report File for "components-srcs"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AfterContentChecked } from '@angular/core';
import { AfterContentInit } from '@angular/core';
import { AfterViewInit } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { CollectionViewer } from '@angular/cdk/collections';
import { DataSource } from '@angular/cdk/collections';
import { ElementRef } from '@angular/core';
import { EventEmitter } from '@angular/core';
import * as i0 from '@angular/core';
import * as i1 from '@angular/common';
import { InjectionToken } from '@angular/core';
import { InputSignal } from '@angular/core';
import { IterableDiffer } from '@angular/core';
import { IterableDiffers } from '@angular/core';
import { Observable } from 'rxjs';
import { OnDestroy } from '@angular/core';
import { OnInit } from '@angular/core';
import { QueryList } from '@angular/core';
import { SelectionModel } from '@angular/cdk/collections';
import { Signal } from '@angular/core';
import { Subject } from 'rxjs';
import { TemplateRef } from '@angular/core';
import { TrackByFunction } from '@angular/core';
import { TreeKeyManagerItem } from '@angular/cdk/a11y';
import { TreeKeyManagerStrategy } from '@angular/cdk/a11y';
import { ViewContainerRef } from '@angular/core';
import { WritableSignal } from '@angular/core';

// @public @deprecated
export abstract class BaseTreeControl<T, K = T> implements TreeControl<T, K> {
    collapse(dataNode: T): void;
    collapseAll(): void;
    collapseDescendants(dataNode: T): void;
    dataNodes: T[];
    expand(dataNode: T): void;
    abstract expandAll(): void;
    expandDescendants(dataNode: T): void;
    expansionModel: SelectionModel<K>;
    getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;
    abstract getDescendants(dataNode: T): T[];
    getLevel: (dataNode: T) => number;
    isExpandable: (dataNode: T) => boolean;
    isExpanded(dataNode: T): boolean;
    toggle(dataNode: T): void;
    toggleDescendants(dataNode: T): void;
    trackBy?: (dataNode: T) => K;
    // (undocumented)
    protected _trackByValue(value: T | K): K;
}

// @public
export const CDK_TREE_NODE_OUTLET_NODE: InjectionToken<{}>;

// @public
export class CdkNestedTreeNode<T, K = T> extends CdkTreeNode<T, K> implements AfterContentInit, OnDestroy {
    constructor(...args: unknown[]);
    protected _children: T[];
    protected _clear(): void;
    // (undocumented)
    protected _differs: IterableDiffers;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    nodeOutlet: QueryList<CdkTreeNodeOutlet>;
    // (undocumented)
    protected _type: 'flat' | 'nested';
    protected updateChildrenNodes(children?: T[]): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkNestedTreeNode<any, any>, "cdk-nested-tree-node", ["cdkNestedTreeNode"], {}, {}, ["nodeOutlet"], never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkNestedTreeNode<any, any>, never>;
}

// @public
export class CdkTree<T, K = T> implements AfterContentChecked, AfterContentInit, AfterViewInit, CollectionViewer, OnDestroy, OnInit {
    constructor(...args: unknown[]);
    childrenAccessor?: (dataNode: T) => T[] | Observable<T[]>;
    collapse(dataNode: T): void;
    collapseAll(): void;
    collapseDescendants(dataNode: T): void;
    get dataSource(): DataSource<T> | Observable<T[]> | T[];
    set dataSource(dataSource: DataSource<T> | Observable<T[]> | T[] | null);
    expand(dataNode: T): void;
    expandAll(): void;
    expandDescendants(dataNode: T): void;
    get expansionKey(): ((dataNode: T) => K) | undefined;
    set expansionKey(expansionKey: (dataNode: T) => K);
    _getChildrenAccessor(): ((dataNode: T) => T[] | Observable<T[]> | null | undefined) | undefined;
    _getDirectChildren(dataNode: T): Observable<T[]>;
    // (undocumented)
    _getExpansionModel(): SelectionModel<K>;
    _getLevel(node: T): number | undefined;
    _getLevelAccessor(): ((dataNode: T) => number) | undefined;
    _getNodeChildren(node: CdkTreeNode<T, K>): Observable<CdkTreeNode<T, K>[]>;
    _getNodeDef(data: T, i: number): CdkTreeNodeDef<T>;
    _getNodeParent(node: CdkTreeNode<T, K>): CdkTreeNode<T, K> | null | undefined;
    _getPositionInSet(dataNode: T): number;
    _getSetSize(dataNode: T): number;
    insertNode(nodeData: T, index: number, viewContainer?: ViewContainerRef, parentData?: T): void;
    isExpanded(dataNode: T): boolean;
    _keyManager: TreeKeyManagerStrategy<CdkTreeNode<T, K>>;
    levelAccessor?: (dataNode: T) => number;
    // (undocumented)
    ngAfterContentChecked(): void;
    // (undocumented)
    ngAfterContentInit(): void;
    // (undocumented)
    ngAfterViewInit(): void;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    _nodeDefs: QueryList<CdkTreeNodeDef<T>>;
    // (undocumented)
    _nodeOutlet: CdkTreeNodeOutlet;
    _registerNode(node: CdkTreeNode<T, K>): void;
    renderNodeChanges(data: readonly T[], dataDiffer?: IterableDiffer<T>, viewContainer?: ViewContainerRef, parentData?: T): void;
    protected _sendKeydownToKeyManager(event: KeyboardEvent): void;
    _setNodeTypeIfUnset(newType: 'flat' | 'nested'): void;
    toggle(dataNode: T): void;
    toggleDescendants(dataNode: T): void;
    get trackBy(): TrackByFunction<T> | undefined;
    set trackBy(trackBy: TrackByFunction<T>);
    // (undocumented)
    readonly _trackByFn: Signal<TrackByFunction<T>>;
    // @deprecated
    treeControl?: TreeControl<T, K>;
    _unregisterNode(node: CdkTreeNode<T, K>): void;
    readonly viewChange: BehaviorSubject<{
        start: number;
        end: number;
    }>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTree<any, any>, "cdk-tree", ["cdkTree"], { "dataSource": { "alias": "dataSource"; "required": false; }; "treeControl": { "alias": "treeControl"; "required": false; }; "levelAccessor": { "alias": "levelAccessor"; "required": false; }; "childrenAccessor": { "alias": "childrenAccessor"; "required": false; }; "trackBy": { "alias": "trackBy"; "required": false; }; "expansionKey": { "alias": "expansionKey"; "required": false; }; }, {}, ["_nodeDefs"], never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTree<any, any>, never>;
}

// @public (undocumented)
export class CdkTreeModule {
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeModule, never>;
    // (undocumented)
    static ɵinj: i0.ɵɵInjectorDeclaration<CdkTreeModule>;
    // (undocumented)
    static ɵmod: i0.ɵɵNgModuleDeclaration<CdkTreeModule, never, [typeof i1_2.CdkNestedTreeNode, typeof i2.CdkTreeNodeDef, typeof i3.CdkTreeNodePadding, typeof i4.CdkTreeNodeToggle, typeof i5.CdkTree, typeof i5.CdkTreeNode, typeof i6.CdkTreeNodeOutlet], [typeof i1_2.CdkNestedTreeNode, typeof i2.CdkTreeNodeDef, typeof i3.CdkTreeNodePadding, typeof i4.CdkTreeNodeToggle, typeof i5.CdkTree, typeof i5.CdkTreeNode, typeof i6.CdkTreeNodeOutlet]>;
}

// @public
export class CdkTreeNode<T, K = T> implements OnDestroy, OnInit, TreeKeyManagerItem {
    constructor(...args: unknown[]);
    activate(): void;
    readonly activation: EventEmitter<T>;
    collapse(): void;
    get data(): T;
    set data(value: T);
    // (undocumented)
    protected _data: T;
    readonly _dataChanges: Subject<void>;
    protected readonly _destroyed: Subject<void>;
    // (undocumented)
    _elementRef: ElementRef<HTMLElement>;
    // (undocumented)
    _emitExpansionState(expanded: boolean): void;
    expand(): void;
    readonly expandedChange: EventEmitter<boolean>;
    focus(): void;
    // (undocumented)
    _focusItem(): void;
    _getAriaExpanded(): string | null;
    // (undocumented)
    getChildren(): CdkTreeNode<T, K>[] | Observable<CdkTreeNode<T, K>[]>;
    // (undocumented)
    getLabel(): string;
    // (undocumented)
    getParent(): CdkTreeNode<T, K> | null;
    _getPositionInSet(): number;
    _getSetSize(): number;
    isDisabled: boolean;
    get isExpandable(): boolean;
    set isExpandable(isExpandable: boolean);
    _isExpandable(): boolean;
    // (undocumented)
    get isExpanded(): boolean;
    set isExpanded(isExpanded: boolean);
    // (undocumented)
    get isLeafNode(): boolean;
    // (undocumented)
    get level(): number;
    makeFocusable(): void;
    static mostRecentTreeNode: CdkTreeNode<any> | null;
    // (undocumented)
    static ngAcceptInputType_isDisabled: unknown;
    // (undocumented)
    static ngAcceptInputType_isExpandable: unknown;
    // (undocumented)
    ngOnDestroy(): void;
    // (undocumented)
    ngOnInit(): void;
    // @deprecated
    get role(): 'treeitem' | 'group';
    set role(_role: 'treeitem' | 'group');
    // (undocumented)
    _setActiveItem(): void;
    // (undocumented)
    protected readonly _tabindex: WritableSignal<number | null>;
    // (undocumented)
    protected _tree: CdkTree<T, K>;
    // (undocumented)
    protected readonly _type: 'flat' | 'nested';
    typeaheadLabel: string | null;
    unfocus(): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNode<any, any>, "cdk-tree-node", ["cdkTreeNode"], { "role": { "alias": "role"; "required": false; }; "isExpandable": { "alias": "isExpandable"; "required": false; }; "isExpanded": { "alias": "isExpanded"; "required": false; }; "isDisabled": { "alias": "isDisabled"; "required": false; }; "typeaheadLabel": { "alias": "cdkTreeNodeTypeaheadLabel"; "required": false; }; }, { "activation": "activation"; "expandedChange": "expandedChange"; }, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNode<any, any>, never>;
}

// @public
export class CdkTreeNodeDef<T> {
    constructor(...args: unknown[]);
    template: TemplateRef<any>;
    when: (index: number, nodeData: T) => boolean;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeDef<any>, "[cdkTreeNodeDef]", never, { "when": { "alias": "cdkTreeNodeDefWhen"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeDef<any>, never>;
}

// @public
export class CdkTreeNodeOutlet {
    constructor(...args: unknown[]);
    // (undocumented)
    _node?: {} | null | undefined;
    // (undocumented)
    viewContainer: ViewContainerRef;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeOutlet, "[cdkTreeNodeOutlet]", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeOutlet, never>;
}

// @public
export class CdkTreeNodeOutletContext<T> {
    $implicit: T;
    constructor(data: T);
    count?: number;
    index?: number;
    level: number;
}

// @public
export class CdkTreeNodeOutletTemplate<T, K> {
    // (undocumented)
    _nodeOutletTemplate: TemplateRef<NodeOutletTemplateContext<T, K>>;
    // (undocumented)
    static ɵcmp: i0.ɵɵComponentDeclaration<CdkTreeNodeOutletTemplate<any, any>, "cdk-tree-node-outlet-template", never, {}, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeOutletTemplate<any, any>, never>;
}

// @public
export class CdkTreeNodePadding<T, K = T> implements OnDestroy {
    constructor(...args: unknown[]);
    get indent(): number | string;
    set indent(indent: number | string);
    // (undocumented)
    _indent: number;
    indentUnits: string;
    get level(): number;
    set level(value: number);
    // (undocumented)
    _level: number;
    // (undocumented)
    static ngAcceptInputType_level: unknown;
    // (undocumented)
    ngOnDestroy(): void;
    _paddingIndent(): string | null;
    protected _setIndentInput(indent: number | string): void;
    protected _setLevelInput(value: number): void;
    // (undocumented)
    _setPadding(forceChange?: boolean): void;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodePadding<any, any>, "[cdkTreeNodePadding]", never, { "level": { "alias": "cdkTreeNodePadding"; "required": false; }; "indent": { "alias": "cdkTreeNodePaddingIndent"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodePadding<any, any>, never>;
}

// @public
export class CdkTreeNodeRenderer<T, K> implements OnInit {
    // (undocumented)
    ngOnInit(): void;
    // (undocumented)
    readonly node: InputSignal<RenderNode<T, K>>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeRenderer<any, any>, "[cdkTreeNodeRenderer]", never, { "node": { "alias": "node"; "required": true; "isSignal": true; }; }, {}, never, never, true, [{ directive: typeof i1.NgTemplateOutlet; inputs: { "ngTemplateOutlet": "template"; "ngTemplateOutletContext": "context"; }; outputs: {}; }]>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeRenderer<any, any>, never>;
}

// @public
export class CdkTreeNodeToggle<T, K = T> {
    constructor(...args: unknown[]);
    // (undocumented)
    static ngAcceptInputType_recursive: unknown;
    recursive: boolean;
    // (undocumented)
    _toggle(): void;
    // (undocumented)
    protected _tree: CdkTree<T, K>;
    // (undocumented)
    protected _treeNode: CdkTreeNode<T, K>;
    // (undocumented)
    static ɵdir: i0.ɵɵDirectiveDeclaration<CdkTreeNodeToggle<any, any>, "[cdkTreeNodeToggle]", never, { "recursive": { "alias": "cdkTreeNodeToggleRecursive"; "required": false; }; }, {}, never, never, true, never>;
    // (undocumented)
    static ɵfac: i0.ɵɵFactoryDeclaration<CdkTreeNodeToggle<any, any>, never>;
}

// @public @deprecated
export class FlatTreeControl<T, K = T> extends BaseTreeControl<T, K> {
    constructor(getLevel: (dataNode: T) => number, isExpandable: (dataNode: T) => boolean, options?: FlatTreeControlOptions<T, K> | undefined);
    expandAll(): void;
    getDescendants(dataNode: T): T[];
    // (undocumented)
    getLevel: (dataNode: T) => number;
    // (undocumented)
    isExpandable: (dataNode: T) => boolean;
    // (undocumented)
    options?: FlatTreeControlOptions<T, K> | undefined;
}

// @public
export interface FlatTreeControlOptions<T, K> {
    // (undocumented)
    trackBy?: (dataNode: T) => K;
}

// @public
export function getMultipleTreeControlsError(): Error;

// @public
export function getTreeControlMissingError(): Error;

// @public
export function getTreeMissingMatchingNodeDefError(): Error;

// @public
export function getTreeMultipleDefaultNodeDefsError(): Error;

// @public
export function getTreeNoValidDataSourceError(): Error;

// @public @deprecated
export class NestedTreeControl<T, K = T> extends BaseTreeControl<T, K> {
    constructor(getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null, options?: NestedTreeControlOptions<T, K> | undefined);
    expandAll(): void;
    // (undocumented)
    getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;
    getDescendants(dataNode: T): T[];
    protected _getDescendants(descendants: T[], dataNode: T): void;
    // (undocumented)
    options?: NestedTreeControlOptions<T, K> | undefined;
}

// @public
export interface NestedTreeControlOptions<T, K> {
    isExpandable?: (dataNode: T) => boolean;
    // (undocumented)
    trackBy?: (dataNode: T) => K;
}

// @public @deprecated
export interface TreeControl<T, K = T> {
    collapse(dataNode: T): void;
    collapseAll(): void;
    collapseDescendants(dataNode: T): void;
    dataNodes: T[];
    expand(dataNode: T): void;
    expandAll(): void;
    expandDescendants(dataNode: T): void;
    expansionModel: SelectionModel<K>;
    readonly getChildren: (dataNode: T) => Observable<T[]> | T[] | undefined | null;
    getDescendants(dataNode: T): any[];
    readonly getLevel: (dataNode: T) => number;
    readonly isExpandable: (dataNode: T) => boolean;
    isExpanded(dataNode: T): boolean;
    toggle(dataNode: T): void;
    toggleDescendants(dataNode: T): void;
}

// (No @packageDocumentation comment for this package)

```
