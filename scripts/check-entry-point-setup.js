#!/usr/bin/env node

/**
 * Script that detects and validates entry-points. The script walks through all
 * source files in the code base and ensures that determined entry-points are
 * configured. The list of configured entry-points in Starlark is passed to the
 * script through a manifest file (generated by Bazel)
 */

const {join, dirname} = require('path');
const {sync: globSync} = require('glob');
const minimatch = require('minimatch');
const fs = require('fs');
const chalk = require('chalk');

const [entryPointManifest] = process.argv.slice(2);
const entryPoints = JSON.parse(fs.readFileSync(entryPointManifest, 'utf8'));
const packagesDir = join(__dirname, '../src');

/**
 * Globs that matches directories which should never be considered
 * as entry-points.
 */
const excludeGlobs = [
  'cdk/testing/private',
  'cdk/private',
  '*/schematics/**',
  // The protractor testing entry-point is no longer publicly available,
  // but exists in the repository until it can be removed in g3.
  'cdk/testing/protractor',
];

/** List of detected entry-points which are not properly configured. */
const nonConfigured = [];

// We require a minimum depth of two. This ensures that we only check entry-points and
// do not check package names (like "cdk"). There is no validation for package names yet.
globSync('*/*/**/public-api.ts', {cwd: packagesDir}).forEach(filePath => {
  const entryPointName = dirname(filePath);

  if (
    !excludeGlobs.some(pattern => minimatch(entryPointName, pattern)) &&
    !entryPoints.includes(entryPointName)
  ) {
    nonConfigured.push(entryPointName);
  }
});

if (nonConfigured.length) {
  console.error(
    chalk.red(
      'Found entry-points which are not configured. Add the following ' +
        'entry-points to the package-specific "config.bzl" file:\n',
    ),
  );
  nonConfigured.forEach(e => console.warn(chalk.yellow(`  - ${e}`)));
  process.exit(1);
} else {
  console.log(chalk.green('All detected entry-points are configured properly.'));
}
